//! moment.js
;(function (global,factory){typeofexports:== object && typeof module !== undefined ? module.exports = factory() : typeof define === function && define.amd ? define(factory) : global.moment = factory()}// This is done to register the method called with moment()
// without creating circular dependencies.
function setHookCallback (callback){hookcallback:callback}function isArray(input){returninputinstanceofarrayobjectprototypetostringcallinput:== '[object Array]'}function isObject(input){}function isObjectEmpty(obj){ifobjectgetownpropertynamesreturnobjectgetownpropertynamesobjlength:== 0)}function isUndefined(input){returninput:== void 0}function isNumber(input){returntypeofinput:== number || Object.prototype.toString.call(input) === '[object Number]'}function isDate(input){returninputinstanceofdateobjectprototypetostringcallinput:== '[object Date]'}function map(arr,fn){varres:[],i;fori:0}function extend(a,b){forvariinbifhasownpropbiai:b[i]}if (hasOwnProp(b,toString)){atostring:b.toString}if (hasOwnProp(b,valueOf)){avalueof:b.valueOf}function defaultParsingFlags(){overflow:-2,charsLeftOver : 0,nullInput : false,invalidMonth : null,invalidFormat : false,userInvalidated : false,iso : false,parsedDateParts : [],meridiem : null,rfc2822 : false,weekdayMismatch : false}function getParsingFlags(m){ifm_pf:= null) { m._pf = defaultParsingFlags()}var some;
if (Array.prototype.some){some:Array.prototype.some}else{some:function (fun) { var t = Object(this);varlen:t.length >>> 0;forvari:0}function isValid(m){ifm_isvalid:= null) { var flags = getParsingFlags(m);varparsedparts:some.call(flags.parsedDateParts,function (i) { return i != null; });varisnowvalid:!isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || (flags.meridiem && parsedParts));ifm_strictisnowvalid:isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined}if (Object.isFrozen == null || !Object.isFrozen(m)){m_isvalid:isNowValid}function createInvalid (flags){varm:createUTC(NaN);ifflags:null) { extend(getParsingFlags(m),flags)}else{getparsingflagsmuserinvalidated:true}// Plugins that add properties should also add the key here (null value),// so we can properly clone ourselves.
var momentProperties = hooks.momentProperties = [];
function copyConfig(to,from){ifisundefinedfrom_isamomentobjectto_isamomentobject:from._isAMomentObject}if (!isUndefined(from._i)){to_i:from._i}if (!isUndefined(from._f)){to_f:from._f}if (!isUndefined(from._l)){to_l:from._l}if (!isUndefined(from._strict)){to_strict:from._strict}if (!isUndefined(from._tzm)){to_tzm:from._tzm}if (!isUndefined(from._isUTC)){to_isutc:from._isUTC}if (!isUndefined(from._offset)){to_offset:from._offset}if (!isUndefined(from._pf)){to_pf:getParsingFlags(from)}if (!isUndefined(from._locale)){to_locale:from._locale}if (momentProperties.length > 0){fori:0;iprop:momentProperties[i];val:from[prop];ifisundefinedvaltoprop:val}var updateInProgress = false;
// Moment prototype object
function Moment(config){this_d:new Date(config._d != null ? config._d.getTime() : NaN);ifthisisvalidthis_d:new Date(NaN)}// Prevent infinite loop in case updateOffset creates new moment
// objects.
if (updateInProgress === false){updateinprogress:false}function isMoment (obj){returnobjinstanceofmomentobj:null && obj._isAMomentObject != null)}function toInt(argumentForCoercion){varcoercednumber:+argumentForCoercion,value = 0;ifcoercednumber:= 0 && isFinite(coercedNumber)) { value = absFloor(coercedNumber)}// compare two arrays,return the number of differences
function compareArrays(array1,array2,dontConvert){varlen:Math.min(array1.length,array2.length),lengthDiff = Math.abs(array1.length - array2.length),diffs = 0,i;fori:0;iifdontconvertarray1i:= array2[i]) || (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) { diffs++}function warn(msg){ifhookssuppressdeprecationwarnings:== false && (typeof console !== 'undefined') && console.warn) { console.warn('Deprecation warning: ' + msg)}function deprecate(msg,fn){varfirsttime:true;returnextendfunctionifhooksdeprecationhandler:null) { hooks.deprecationHandler(null,msg)}if (firstTime){varargs:[];forvari:0;iftypeofargumentsi:== object) { arg += \n[ + i + '] ';forvarkeyinarguments0arg:key + ': ' + arguments[0][key] + ','}else{arg:arguments[i]};
function deprecateSimple(name,msg){ifhooksdeprecationhandler:null) { hooks.deprecationHandler(name,msg)}if (!deprecations[name]){deprecationsname:true}hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;
function isFunction(input){returninputinstanceoffunctionobjectprototypetostringcallinput:== '[object Function]'}function set (config){foriinconfigprop:config[i];ifisfunctionpropthisi:prop}else{this_i:prop}function mergeConfigs(parentConfig,childConfig){varres:extend({},parentConfig),prop;forpropinchildconfigifhasownpropchildconfigpropifisobjectparentconfigpropisobjectchildconfigpropresprop:{}else if (childConfig[prop] != null){resprop:childConfig[prop]}for (prop in parentConfig){ifhasownpropparentconfigprophasownpropchildconfigpropisobjectparentconfigprop//makesurechangestopropertiesdontmodifyparentconfigresprop:extend({},res[prop])}function Locale(config){ifconfig:null) { this.set(config)}var keys;
if (Object.keys){keys:Object.keys}else{keys:function (obj) { var i,res = []}var defaultCalendar ={sameday:'[Today at] LT',nextDay : '[Tomorrow at] LT',nextWeek : 'dddd [at] LT',lastDay : '[Yesterday at] LT',lastWeek : '[Last] dddd [at] LT',sameElse : L};
function calendar (key,mom,now){varoutput:this._calendar[key] || this._calendar[sameElse];returnisfunctionoutputoutputcallmomnow:output}var defaultLongDateFormat ={lts:'h:mm:ss A',LT : 'h:mm A',L : MM/DD/YYYY,LL : 'MMMM D,YYYY',LLL : 'MMMM D,YYYY h:mm A',LLLL : 'dddd,MMMM D,YYYY h:mm A'};
function longDateFormat (key){varformat:this._longDateFormat[key],formatUpper = this._longDateFormat[key.toUpperCase()]}var defaultRelativeTime ={future:'in %s',past : '%s ago',s : 'a few seconds',ss : '%d seconds',m : 'a minute',mm : '%d minutes',h : 'an hour',hh : '%d hours',d : 'a day',dd : '%d days',M : 'a month',MM : '%d months',y : 'a year',yy : '%d years'};
function relativeTime (number,withoutSuffix,string,isFuture){varoutput:this._relativeTime[string];returnisfunctionoutputoutputnumberwithoutsuffixstringisfuture:output.replace(/%d/i,number)}function pastFuture (diff,output){varformat:this._relativeTime[diff > 0 ? future : past];returnisfunctionformatformatoutput:format.replace(/%s/i,output)};
function addUnitAlias (unit,shorthand){varlowercase:unit.toLowerCase();aliaseslowercase:aliases[lowerCase + s] = aliases[shorthand] = unit}function normalizeUnits(units){returntypeofunits:== string ? aliases[units] || aliases[units.toLowerCase()] : undefined}function normalizeObjectUnits(inputObject){varnormalizedinput:{},normalizedProp,prop;
for (prop in inputObject){ifhasownpropinputobjectpropnormalizedprop:normalizeUnits(prop);ifnormalizedpropnormalizedinputnormalizedprop:inputObject[prop]};
function addUnitPriority(unit,priority){prioritiesunit:priority}function getPrioritizedUnits(unitsObj){varunits:[];forvaruinunitsobjunitspushunit:u,priority: priorities[u]}function zeroFill(number,targetLength,forceSign){varabsnumber:+ Math.abs(number),zerosToFill = targetLength - absNumber.length,sign = number >= 0;returnsignforcesign:) : -) + Math.pow(10,Math.max(0,zerosToFill)).toString().substr(1) + absNumber}function addFormatToken (token,padded,ordinal,callback){varfunc:callback;iftypeofcallback:== string) { func = function () { return this[callback]()}if (token){formattokenfunctionstoken:func}if (padded){formattokenfunctionspadded0:function () { return zeroFill(func.apply(this,arguments),padded[1],padded[2])}if (ordinal){formattokenfunctionsordinal:function () { return this.localeData().ordinal(func.apply(this,arguments),token)}function makeFormatFunction(format){vararray:format.match(formattingTokens),i,length;fori:0,length = array.length;iifformattokenfunctionsarrayiarrayi:formatTokenFunctions[array[i]]}else{arrayi:removeFormattingTokens(array[i])}return function (mom){varoutput:,i;fori:0;ioutput:isFunction(array[i]) ? array[i].call(mom,format) : array[i]}function expandFormat(format,locale){vari:5}localFormattingTokens.lastIndex = 0;
while (i >= 0 && localFormattingTokens.test(format)){format:format.replace(localFormattingTokens,replaceLongDateFormatTokens);localformattingtokenslastindex:0;i-:1}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;\A\A    var regexes = {};\A\A    function addRegexToken (token, regex, strictRegex) {\A        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {\A            return (isStrict && strictRegex) ? strictRegex : regex;\A        };\A    }\A\A    function getParseRegexForToken (token, config) {\A        if (!hasOwnProp(regexes, token)) {\A            return new RegExp(unescapeFormat(token));\A        }\A\A        return regexes[token](config._strict, config._locale);\A    }\A\A    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\A    function unescapeFormat(s) {\A        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {\A            return p1 || p2 || p3 || p4;\A        }));\A    }\A\A    function regexEscape(s) {\A        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');\A    }\A\A    var tokens = {};\A\A    function addParseToken (token, callback) {\A        var i, func = callback;\A        if (typeof token === 'string') {\A            token = [token];\A        }\A        if (isNumber(callback)) {\A            func = function (input, array) {\A                array[callback] = toInt(input);\A            };\A        }\A        for (i = 0; i < token.length; i++) {\A            tokens[token[i]] = func;\A        }\A    }\A\A    function addWeekParseToken (token, callback) {\A        addParseToken(token, function (input, array, config, token) {\A            config._w = config._w || {};\A            callback(input, config._w, config, token);\A        });\A    }\A\A    function addTimeToArrayFromToken(token, input, config) {\A        if (input != null && hasOwnProp(tokens, token)) {\A            tokens[token](input, config._a, config, token);\A        }\A    }\A\A    var YEAR = 0;\A    var MONTH = 1;\A    var DATE = 2;\A    var HOUR = 3;\A    var MINUTE = 4;\A    var SECOND = 5;\A    var MILLISECOND = 6;\A    var WEEK = 7;\A    var WEEKDAY = 8;\A\A    // FORMATTING\A\A    addFormatToken('Y', 0, 0, function () {\A        var y = this.year();\A        return y <= 9999 ? '' + y : '+' + y;\A    });\A\A    addFormatToken(0, ['YY', 2], 0, function () {\A        return this.year() % 100;\A    });\A\A    addFormatToken(0, ['YYYY',   4],       0, 'year');\A    addFormatToken(0, ['YYYYY',  5],       0, 'year');\A    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');\A\A    // ALIASES\A\A    addUnitAlias('year', 'y');\A\A    // PRIORITIES\A\A    addUnitPriority('year', 1);\A\A    // PARSING\A\A    addRegexToken('Y',      matchSigned);\A    addRegexToken('YY',     match1to2, match2);\A    addRegexToken('YYYY',   match1to4, match4);\A    addRegexToken('YYYYY',  match1to6, match6);\A    addRegexToken('YYYYYY', match1to6, match6);\A\A    addParseToken(['YYYYY', 'YYYYYY'], YEAR);\A    addParseToken('YYYY', function (input, array) {\A        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);\A    });\A    addParseToken('YY', function (input, array) {\A        array[YEAR] = hooks.parseTwoDigitYear(input);\A    });\A    addParseToken('Y', function (input, array) {\A        array[YEAR] = parseInt(input, 10);\A    });\A\A    // HELPERS\A\A    function daysInYear(year) {\A        return isLeapYear(year) ? 366 : 365;\A    }\A\A    function isLeapYear(year) {\A        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\A    }\A\A    // HOOKS\A\A    hooks.parseTwoDigitYear = function (input) {\A        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\A    };\A\A    // MOMENTS\A\A    var getSetYear = makeGetSet('FullYear', true);\A\A    function getIsLeapYear () {\A        return isLeapYear(this.year());\A    }\A\A    function makeGetSet (unit, keepTime) {\A        return function (value) {\A            if (value != null) {\A                set$1(this, unit, value);\A                hooks.updateOffset(this, keepTime);\A                return this;\A            } else {\A                return get(this, unit);\A            }\A        };\A    }\A\A    function get (mom, unit) {\A        return mom.isValid() ?\A            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;\A    }\A\A    function set$1 (mom, unit, value) {\A        if (mom.isValid() && !isNaN(value)) {\A            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {\A                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));\A            }\A            else {\A                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);\A            }\A        }\A    }\A\A    // MOMENTS\A\A    function stringGet (units) {\A        units = normalizeUnits(units);\A        if (isFunction(this[units])) {\A            return this[units]();\A        }\A        return this;\A    }\A\A\A    function stringSet (units, value) {\A        if (typeof units === 'object') {\A            units = normalizeObjectUnits(units);\A            var prioritized = getPrioritizedUnits(units);\A            for (var i = 0; i < prioritized.length; i++) {\A                this[prioritized[i].unit](units[prioritized[i].unit]);\A            }\A        } else {\A            units = normalizeUnits(units);\A            if (isFunction(this[units])) {\A                return this[units](value);\A            }\A        }\A        return this;\A    }\A\A    function mod(n, x) {\A        return ((n % x) + x) % x;\A    }\A\A    var indexOf;\A\A    if (Array.prototype.indexOf) {\A        indexOf = Array.prototype.indexOf;\A    } else {\A        indexOf = function (o) {\A            // I know\A            var i;\A            for (i = 0; i < this.length; ++i) {\A                if (this[i] === o) {\A                    return i;\A                }\A            }\A            return -1;\A        };\A    }\A\A    function daysInMonth(year, month) {\A        if (isNaN(year) || isNaN(month)) {\A            return NaN;\A        }\A        var modMonth = mod(month, 12);\A        year += (month - modMonth) / 12;\A        return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);\A    }\A\A    // FORMATTING\A\A    addFormatToken('M', ['MM', 2], 'Mo', function () {\A        return this.month() + 1;\A    });\A\A    addFormatToken('MMM', 0, 0, function (format) {\A        return this.localeData().monthsShort(this, format);\A    });\A\A    addFormatToken('MMMM', 0, 0, function (format) {\A        return this.localeData().months(this, format);\A    });\A\A    // ALIASES\A\A    addUnitAlias('month', 'M');\A\A    // PRIORITY\A\A    addUnitPriority('month', 8);\A\A    // PARSING\A\A    addRegexToken('M',    match1to2);\A    addRegexToken('MM',   match1to2, match2);\A    addRegexToken('MMM',  function (isStrict, locale) {\A        return locale.monthsShortRegex(isStrict);\A    });\A    addRegexToken('MMMM', function (isStrict, locale) {\A        return locale.monthsRegex(isStrict);\A    });\A\A    addParseToken(['M', 'MM'], function (input, array) {\A        array[MONTH] = toInt(input) - 1;\A    });\A\A    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {\A        var month = config._locale.monthsParse(input, token, config._strict);\A        // if we didn't find a month name,mark the date as invalid.
if (month != null){arraymonth:month}else{getparsingflagsconfiginvalidmonth:input});
// LOCALES
var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|s)+MMMM?/;
var defaultLocaleMonths = January_February_March_April_May_June_July_August_September_October_November_December.split(_);
function localeMonths (m,format){ifmreturnisarraythis_monthsthis_months:this._months[standalone]}var defaultLocaleMonthsShort = Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec.split(_);
function localeMonthsShort (m,format){ifmreturnisarraythis_monthsshortthis_monthsshort:this._monthsShort[standalone]}function handleStrictParse(monthName,format,strict){variiimomllc:monthName.toLocaleLowerCase();ifthis_monthsparse//thisisnotusedthis_monthsparse:[];this_longmonthsparse:[];this_shortmonthsparse:[];fori:0;+imom:createUTC([2000,i]);this_shortmonthsparsei:this.monthsShort(mom,'').toLocaleLowerCase();this_longmonthsparsei:this.months(mom,'').toLocaleLowerCase()}if (strict){ifformat:== MMM) { ii = indexOf.call(this._shortMonthsParse,llc);returnii:= -1 ? ii : null}else{ii:indexOf.call(this._longMonthsParse,llc);returnii:= -1 ? ii : null}else{ifformat:== MMM) { ii = indexOf.call(this._shortMonthsParse,llc);ifii:= -1) { return ii}else{ii:indexOf.call(this._longMonthsParse,llc);ifii:= -1) { return ii}if (!this._monthsParse){this_monthsparse:[];this_longmonthsparse:[];this_shortmonthsparse:[]}// TODO: add sorting
// Sorting makes sure if one month (or abbr) is a prefix of another
// see sorting in computeMonthsParse
for (i = 0; i < 12; i++){ifstrictthis_longmonthsparseithis_longmonthsparsei:new RegExp(^ + this.months(mom,'').replace(.,'') + '$','i');this_shortmonthsparsei:new RegExp(^ + this.monthsShort(mom,'').replace(.,'') + '$','i')}if (!strict && !this._monthsParse[i]){regex:^ + this.months(mom,'') + |^ + this.monthsShort(mom,'');this_monthsparsei:new RegExp(regex.replace(.,''),'i')}if (typeof value === string){if/\d/testvaluevalue:toInt(value)}else{value:mom.localeData().monthsParse(value)}function getSetMonth (value){ifvalue:null) { setMonth(this,value)}else{ifhasownpropthis_monthsshortregexthis_monthsshortregex:defaultMonthsShortRegex}else{ifhasownpropthis_monthsregexthis_monthsregex:defaultMonthsRegex}var shortPieces = [],longPieces = [],mixedPieces = [],i,mom;
for (i = 0; i < 12; i++){}// Sorting makes sure if one month (or abbr) is a prefix of another it
// will match the longer piece.
shortPieces.sort(cmpLenRev);
longPieces.sort(cmpLenRev);
mixedPieces.sort(cmpLenRev);
for (i = 0; i < 12; i++){shortpiecesi:regexEscape(shortPieces[i]);longpiecesi:regexEscape(longPieces[i])}for (i = 0; i < 24; i++){mixedpiecesi:regexEscape(mixedPieces[i])}function createDate (y,m,d,h,M,s,ms){}else{date:new Date(y,m,d,h,M,s,ms)}function createUTCDate (y){date:new Date(Date.UTC.apply(null,args))}else{date:new Date(Date.UTC.apply(null,arguments))}// start-of-first-week - start-of-year
function firstWeekOffset(year,dow,doy){var//first-weekday--whichjanuaryisalwaysinthefirstweek4foriso1forotherfwd:7 + dow - doy,// first-week day local weekday -- which local weekday is fwd fwdlw = (7 + createUTCDate(year,0,fwd).getUTCDay() - dow) % 7}// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
function dayOfYearFromWeeks(year,week,weekday,dow,doy){varlocalweekday:(7 + weekday - dow) % 7,weekOffset = firstWeekOffset(year,dow,doy),dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,resYear,resDayOfYear;ifdayofyear:0) { resYear = year - 1;resdayofyear:daysInYear(resYear) + dayOfYear}else if (dayOfYear > daysInYear(year)){resyear:year + 1;resdayofyear:dayOfYear - daysInYear(year)}else{resyear:year;resdayofyear:dayOfYear}return{year:resYear,dayOfYear: resDayOfYear}function weekOfYear(mom,dow,doy){varweekoffset:firstWeekOffset(mom.year(),dow,doy),week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,resWeek,resYear;ifweek1resyear:mom.year() - 1;resweek:week + weeksInYear(resYear,dow,doy)}else if (week > weeksInYear(mom.year(),dow,doy)){resweek:week - weeksInYear(mom.year(),dow,doy);resyear:mom.year() + 1}else{resyear:mom.year();resweek:week}return{week:resWeek,year: resYear}function weeksInYear(year,dow,doy){varweekoffset:firstWeekOffset(year,dow,doy),weekOffsetNext = firstWeekOffset(year + 1,dow,doy)}// FORMATTING
addFormatToken(w,[ww,2],wo,week);
addFormatToken(W,[WW,2],Wo,isoWeek);
// ALIASES
addUnitAlias(week,w);
addUnitAlias(isoWeek,W);
// PRIORITIES
addUnitPriority(week,5);
addUnitPriority(isoWeek,5);
// PARSING
addRegexToken(w,match1to2);
addRegexToken(ww,match1to2,match2);
addRegexToken(W,match1to2);
addRegexToken(WW,match1to2,match2);
addWeekParseToken([w,ww,W,WW],function (input,week,config,token){weektokensubstr01:toInt(input)}var defaultLocaleWeek ={dow:0,// Sunday is the first day of the week. doy : 6 // The week that contains Jan 6th is the first week of the year.}// MOMENTS
function getSetWeek (input){varweek:this.localeData().week(this);returninput:= null ? week : this.add((input - week) * 7,'d')}function getSetISOWeek (input){varweek:weekOfYear(this,1,4).week;returninput:= null ? week : this.add((input - week) * 7,'d')});
addWeekParseToken([dd,ddd,dddd],function (input,week,config,token){varweekday:config._locale.weekdaysParse(input,token,config._strict)}else{getparsingflagsconfiginvalidweekday:input});
addWeekParseToken([d,e,E],function (input,week,config,token){weektoken:toInt(input)});
// HELPERS
function parseWeekday(input,locale){iftypeofinput:= string) { return input}function parseIsoWeekday(input,locale){iftypeofinput:== string) { return locale.weekdaysParse(input) % 7 || 7}var defaultLocaleWeekdays = Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday.split(_);
function localeWeekdays (m,format){varweekdays:isArray(this._weekdays) ? this._weekdays : this._weekdays[(m && m !== true && this._weekdays.isFormat.test(format)) ? format : standalone];returnm:== true) ? shiftWeekdays(weekdays,this._week.dow) : (m) ? weekdays[m.day()] : weekdays}var defaultLocaleWeekdaysShort = Sun_Mon_Tue_Wed_Thu_Fri_Sat.split(_);
function localeWeekdaysShort (m){returnm:== true) ? shiftWeekdays(this._weekdaysShort,this._week.dow) : (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort}var defaultLocaleWeekdaysMin = Su_Mo_Tu_We_Th_Fr_Sa.split(_);
function localeWeekdaysMin (m){returnm:== true) ? shiftWeekdays(this._weekdaysMin,this._week.dow) : (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin}function handleStrictParse$1(weekdayName,format,strict){variiimomllc:weekdayName.toLocaleLowerCase();ifthis_weekdaysparsethis_weekdaysparse:[];this_shortweekdaysparse:[];this_minweekdaysparse:[];fori:0;+imom:createUTC([2000,1]).day(i);this_minweekdaysparsei:this.weekdaysMin(mom,'').toLocaleLowerCase();this_shortweekdaysparsei:this.weekdaysShort(mom,'').toLocaleLowerCase();this_weekdaysparsei:this.weekdays(mom,'').toLocaleLowerCase()}if (strict){ifformat:== dddd) { ii = indexOf.call(this._weekdaysParse,llc);returnii:= -1 ? ii : null}else if (format === ddd){ii:indexOf.call(this._shortWeekdaysParse,llc);returnii:= -1 ? ii : null}else{ii:indexOf.call(this._minWeekdaysParse,llc);returnii:= -1 ? ii : null}else{ifformat:== dddd) { ii = indexOf.call(this._weekdaysParse,llc);ifii:= -1) { return ii}else if (format === ddd){ii:indexOf.call(this._shortWeekdaysParse,llc);ifii:= -1) { return ii}else{ii:indexOf.call(this._minWeekdaysParse,llc);ifii:= -1) { return ii}if (!this._weekdaysParse){this_weekdaysparse:[];this_minweekdaysparse:[];this_shortweekdaysparse:[];this_fullweekdaysparse:[]}for (i = 0; i < 7; i++){ifstrictthis_fullweekdaysparseithis_fullweekdaysparsei:new RegExp(^ + this.weekdays(mom,'').replace(.,'\\.?') + '$','i');this_shortweekdaysparsei:new RegExp(^ + this.weekdaysShort(mom,'').replace(.,'\\.?') + '$','i');this_minweekdaysparsei:new RegExp(^ + this.weekdaysMin(mom,'').replace(.,'\\.?') + '$','i')}if (!this._weekdaysParse[i]){regex:^ + this.weekdays(mom,'') + |^ + this.weekdaysShort(mom,'') + |^ + this.weekdaysMin(mom,'');this_weekdaysparsei:new RegExp(regex.replace(.,''),'i')}// MOMENTS
function getSetDayOfWeek (input){ifthisisvalidreturninput:null ? this : NaN}var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
if (input != null){input:parseWeekday(input,this.localeData())}function getSetLocaleDayOfWeek (input){ifthisisvalidreturninput:null ? this : NaN}function getSetISODayOfWeek (input){ifthisisvalidreturninput:null ? this : NaN}// behaves the same as moment#day except
// as a getter,returns 7 instead of 0 (1-7 range instead of 0-6)
// as a setter,sunday should belong to the previous week.
if (input != null){varweekday:parseIsoWeekday(input,this.localeData());returnthisdaythisday7weekday:weekday - 7)}else{ifhasownpropthis_weekdaysregexthis_weekdaysregex:defaultWeekdaysRegex}else{ifhasownpropthis_weekdaysshortregexthis_weekdaysshortregex:defaultWeekdaysShortRegex}else{ifhasownpropthis_weekdaysminregexthis_weekdaysminregex:defaultWeekdaysMinRegex}var minPieces = [],shortPieces = [],longPieces = [],mixedPieces = [],i,mom,minp,shortp,longp;
for (i = 0; i < 7; i++){minp:this.weekdaysMin(mom,'');shortp:this.weekdaysShort(mom,'');longp:this.weekdays(mom,'')}// Sorting makes sure if one weekday (or abbr) is a prefix of another it
// will match the longer piece.
minPieces.sort(cmpLenRev);
shortPieces.sort(cmpLenRev);
longPieces.sort(cmpLenRev);
mixedPieces.sort(cmpLenRev);
for (i = 0; i < 7; i++){shortpiecesi:regexEscape(shortPieces[i]);longpiecesi:regexEscape(longPieces[i]);mixedpiecesi:regexEscape(mixedPieces[i])}addRegexToken(a,matchMeridiem);
addRegexToken(A,matchMeridiem);
addRegexToken(H,match1to2);
addRegexToken(h,match1to2);
addRegexToken(k,match1to2);
addRegexToken(HH,match1to2,match2);
addRegexToken(hh,match1to2,match2);
addRegexToken(kk,match1to2,match2);
addRegexToken(hmm,match3to4);
addRegexToken(hmmss,match5to6);
addRegexToken(Hmm,match3to4);
addRegexToken(Hmmss,match5to6);
addParseToken([H,HH],HOUR);
addParseToken([k,kk],function (input,array,config){varkinput:toInt(input);arrayhour:kInput === 24 ? 0 : kInput});
addParseToken([a,A],function (input,array,config){config_ispm:config._locale.isPM(input);config_meridiem:input});
addParseToken([h,hh],function (input,array,config){arrayhour:toInt(input);getparsingflagsconfigbighour:true});
addParseToken(hmm,function (input,array,config){varpos:input.length - 2;arrayhour:toInt(input.substr(0,pos));arrayminute:toInt(input.substr(pos));getparsingflagsconfigbighour:true});
addParseToken(hmmss,function (input,array,config){varpos1:input.length - 4;varpos2:input.length - 2;arrayhour:toInt(input.substr(0,pos1));arrayminute:toInt(input.substr(pos1,2));arraysecond:toInt(input.substr(pos2));getparsingflagsconfigbighour:true});
addParseToken(Hmm,function (input,array,config){varpos:input.length - 2;arrayhour:toInt(input.substr(0,pos));arrayminute:toInt(input.substr(pos))});
addParseToken(Hmmss,function (input,array,config){varpos1:input.length - 4;varpos2:input.length - 2;arrayhour:toInt(input.substr(0,pos1));arrayminute:toInt(input.substr(pos1,2));arraysecond:toInt(input.substr(pos2))});
// LOCALES
function localeIsPM (input){}var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
function localeMeridiem (hours,minutes,isLower){ifhours11returnislowerpm:PM}else{returnisloweram:AM}// MOMENTS
// Setting the hour should keep the time,because the user explicitly
// specified which hour they want. So trying to maintain the same hour (in
// a new timezone) makes sense. Adding/subtracting hours does not follow
// this rule.
var getSetHour = makeGetSet(Hours,true);
var baseConfig ={calendar:defaultCalendar,longDateFormat: defaultLongDateFormat,invalidDate: defaultInvalidDate,ordinal: defaultOrdinal,dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,relativeTime: defaultRelativeTime,months: defaultLocaleMonths,monthsShort: defaultLocaleMonthsShort,week: defaultLocaleWeek,weekdays: defaultLocaleWeekdays,weekdaysMin: defaultLocaleWeekdaysMin,weekdaysShort: defaultLocaleWeekdaysShort,meridiemParse: defaultLocaleMeridiemParse};
var globalLocale;
function normalizeLocale(key){returnkeykeytolowercasereplace_-:key}function updateLocale(name,config){ifconfig:null) { var locale,tmpLocale,parentConfig = baseConfig;iftmplocale:null) { parentConfig = tmpLocale._config}else{}// returns locale data
function getLocale (key){ifkeykey_localekey_locale_abbrkey:key._locale._abbr}if (!isArray(key)){}function checkOverflow (m){vara:m._a;ifagetparsingflagsmoverflow:== -2) { overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR],a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;ifgetparsingflagsm_overflowdayofyearoverflowyearoverflowdateoverflow:DATE}if (getParsingFlags(m)._overflowWeeks && overflow === -1){overflow:WEEK}if (getParsingFlags(m)._overflowWeekday && overflow === -1){overflow:WEEKDAY}// Pick the first defined of two or three arguments.
function defaults(a,b,c){ifa:null) { return a}function currentDateArray(config){}// convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year,month,day,hour,minute,second,millisecond]
function configFromArray (config){varidateinput:[],currentDate,expectedWeekday,yearToUse}//if the day of the year is set,figure out what it is
if (config._dayOfYear != null){yeartouse:defaults(config._a[YEAR],currentDate[YEAR]);ifconfig_dayofyeardaysinyearyeartouseconfig_dayofyear:== 0) { getParsingFlags(config)._overflowDayOfYear = true}// Default to current date.
// * if no year,month,day of month are given,default to today
// * if day of month is given,default month and year
// * if month is given,default only year
// * if year is given,don't default anything\A        for (i = 0; i < 3 && config._a[i] == null; ++i) {\A            config._a[i] = input[i] = currentDate[i];\A        }\A\A        // Zero out whatever was not defaulted, including time\A        for (; i < 7; i++) {\A            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];\A        }\A\A        // Check for 24:00:00.000\A        if (config._a[HOUR] === 24 &&\A                config._a[MINUTE] === 0 &&\A                config._a[SECOND] === 0 &&\A                config._a[MILLISECOND] === 0) {\A            config._nextDay = true;\A            config._a[HOUR] = 0;\A        }\A\A        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);\A        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();\A\A        // Apply timezone offset from input. The actual utcOffset can be changed\A        // with parseZone.\A        if (config._tzm != null) {\A            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\A        }\A\A        if (config._nextDay) {\A            config._a[HOUR] = 24;\A        }\A\A        // check for mismatching day of week\A        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {\A            getParsingFlags(config).weekdayMismatch = true;\A        }\A    }\A\A    function dayOfYearFromWeekInfo(config) {\A        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;\A\A        w = config._w;\A        if (w.GG != null || w.W != null || w.E != null) {\A            dow = 1;\A            doy = 4;\A\A            // TODO: We need to take the current isoWeekYear, but that depends on\A            // how we interpret now (local, utc, fixed offset). So create\A            // a now version of current config (take local/utc/offset flags, and\A            // create now).\A            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);\A            week = defaults(w.W, 1);\A            weekday = defaults(w.E, 1);\A            if (weekday < 1 || weekday > 7) {\A                weekdayOverflow = true;\A            }\A        } else {\A            dow = config._locale._week.dow;\A            doy = config._locale._week.doy;\A\A            var curWeek = weekOfYear(createLocal(), dow, doy);\A\A            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);\A\A            // Default to current week.\A            week = defaults(w.w, curWeek.week);\A\A            if (w.d != null) {\A                // weekday -- low day numbers are considered next week\A                weekday = w.d;\A                if (weekday < 0 || weekday > 6) {\A                    weekdayOverflow = true;\A                }\A            } else if (w.e != null) {\A                // local weekday -- counting starts from beginning of week\A                weekday = w.e + dow;\A                if (w.e < 0 || w.e > 6) {\A                    weekdayOverflow = true;\A                }\A            } else {\A                // default to beginning of week\A                weekday = dow;\A            }\A        }\A        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {\A            getParsingFlags(config)._overflowWeeks = true;\A        } else if (weekdayOverflow != null) {\A            getParsingFlags(config)._overflowWeekday = true;\A        } else {\A            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);\A            config._a[YEAR] = temp.year;\A            config._dayOfYear = temp.dayOfYear;\A        }\A    }\A\A    // iso 8601 regex\A    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)\A    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;\A    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;\A\A    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;\A\A    var isoDates = [\A        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],\A        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],\A        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],\A        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],\A        ['YYYY-DDD', /\d{4}-\d{3}/],\A        ['YYYY-MM', /\d{4}-\d\d/, false],\A        ['YYYYYYMMDD', /[+-]\d{10}/],\A        ['YYYYMMDD', /\d{8}/],\A        // YYYYMM is NOT allowed by the standard\A        ['GGGG[W]WWE', /\d{4}W\d{3}/],\A        ['GGGG[W]WW', /\d{4}W\d{2}/, false],\A        ['YYYYDDD', /\d{7}/]\A    ];\A\A    // iso time formats and regexes\A    var isoTimes = [\A        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],\A        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],\A        ['HH:mm:ss', /\d\d:\d\d:\d\d/],\A        ['HH:mm', /\d\d:\d\d/],\A        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],\A        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],\A        ['HHmmss', /\d\d\d\d\d\d/],\A        ['HHmm', /\d\d\d\d/],\A        ['HH', /\d\d/]\A    ];\A\A    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;\A\A    // date from iso format\A    function configFromISO(config) {\A        var i, l,\A            string = config._i,\A            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),\A            allowTime, dateFormat, timeFormat, tzFormat;\A\A        if (match) {\A            getParsingFlags(config).iso = true;\A\A            for (i = 0, l = isoDates.length; i < l; i++) {\A                if (isoDates[i][1].exec(match[1])) {\A                    dateFormat = isoDates[i][0];\A                    allowTime = isoDates[i][2] !== false;\A                    break;\A                }\A            }\A            if (dateFormat == null) {\A                config._isValid = false;\A                return;\A            }\A            if (match[3]) {\A                for (i = 0, l = isoTimes.length; i < l; i++) {\A                    if (isoTimes[i][1].exec(match[3])) {\A                        // match[2] should be 'T' or space\A                        timeFormat = (match[2] || ' ') + isoTimes[i][0];\A                        break;\A                    }\A                }\A                if (timeFormat == null) {\A                    config._isValid = false;\A                    return;\A                }\A            }\A            if (!allowTime && timeFormat != null) {\A                config._isValid = false;\A                return;\A            }\A            if (match[4]) {\A                if (tzRegex.exec(match[4])) {\A                    tzFormat = 'Z';\A                } else {\A                    config._isValid = false;\A                    return;\A                }\A            }\A            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');\A            configFromStringAndFormat(config);\A        } else {\A            config._isValid = false;\A        }\A    }\A\A    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3\A    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;\A\A    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {\A        var result = [\A            untruncateYear(yearStr),\A            defaultLocaleMonthsShort.indexOf(monthStr),\A            parseInt(dayStr, 10),\A            parseInt(hourStr, 10),\A            parseInt(minuteStr, 10)\A        ];\A\A        if (secondStr) {\A            result.push(parseInt(secondStr, 10));\A        }\A\A        return result;\A    }\A\A    function untruncateYear(yearStr) {\A        var year = parseInt(yearStr, 10);\A        if (year <= 49) {\A            return 2000 + year;\A        } else if (year <= 999) {\A            return 1900 + year;\A        }\A        return year;\A    }\A\A    function preprocessRFC2822(s) {\A        // Remove comments and folding whitespace and replace multiple-spaces with a single space\A        return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');\A    }\A\A    function checkWeekday(weekdayStr, parsedInput, config) {\A        if (weekdayStr) {\A            // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.\A            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),\A                weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();\A            if (weekdayProvided !== weekdayActual) {\A                getParsingFlags(config).weekdayMismatch = true;\A                config._isValid = false;\A                return false;\A            }\A        }\A        return true;\A    }\A\A    var obsOffsets = {\A        UT: 0,\A        GMT: 0,\A        EDT: -4 * 60,\A        EST: -5 * 60,\A        CDT: -5 * 60,\A        CST: -6 * 60,\A        MDT: -6 * 60,\A        MST: -7 * 60,\A        PDT: -7 * 60,\A        PST: -8 * 60\A    };\A\A    function calculateOffset(obsOffset, militaryOffset, numOffset) {\A        if (obsOffset) {\A            return obsOffsets[obsOffset];\A        } else if (militaryOffset) {\A            // the only allowed military tz is Z\A            return 0;\A        } else {\A            var hm = parseInt(numOffset, 10);\A            var m = hm % 100, h = (hm - m) / 100;\A            return h * 60 + m;\A        }\A    }\A\A    // date and time from ref 2822 format\A    function configFromRFC2822(config) {\A        var match = rfc2822.exec(preprocessRFC2822(config._i));\A        if (match) {\A            var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);\A            if (!checkWeekday(match[1], parsedArray, config)) {\A                return;\A            }\A\A            config._a = parsedArray;\A            config._tzm = calculateOffset(match[8], match[9], match[10]);\A\A            config._d = createUTCDate.apply(null, config._a);\A            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\A\A            getParsingFlags(config).rfc2822 = true;\A        } else {\A            config._isValid = false;\A        }\A    }\A\A    // date from iso format or fallback\A    function configFromString(config) {\A        var matched = aspNetJsonRegex.exec(config._i);\A\A        if (matched !== null) {\A            config._d = new Date(+matched[1]);\A            return;\A        }\A\A        configFromISO(config);\A        if (config._isValid === false) {\A            delete config._isValid;\A        } else {\A            return;\A        }\A\A        configFromRFC2822(config);\A        if (config._isValid === false) {\A            delete config._isValid;\A        } else {\A            return;\A        }\A\A        // Final attempt, use Input Fallback\A        hooks.createFromInputFallback(config);\A    }\A\A    hooks.createFromInputFallback = deprecate(\A        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(),' +\A        'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +\A        'discouraged and will be removed in an upcoming major release. Please refer to ' +\A        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',\A        function (config) {\A            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));\A        }\A    );\A\A    // constant that refers to the ISO standard\A    hooks.ISO_8601 = function () {};\A\A    // constant that refers to the RFC 2822 form\A    hooks.RFC_2822 = function () {};\A\A    // date from string and format string\A    function configFromStringAndFormat(config) {\A        // TODO: Move this to another part of the creation flow to prevent circular deps\A        if (config._f === hooks.ISO_8601) {\A            configFromISO(config);\A            return;\A        }\A        if (config._f === hooks.RFC_2822) {\A            configFromRFC2822(config);\A            return;\A        }\A        config._a = [];\A        getParsingFlags(config).empty = true;\A\A        // This array is used to make a Date, either with `new Date` or `Date.UTC`\A        var string = '' + config._i,\A            i, parsedInput, tokens, token, skipped,\A            stringLength = string.length,\A            totalParsedInputLength = 0;\A\A        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\A\A        for (i = 0; i < tokens.length; i++) {\A            token = tokens[i];\A            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];\A            // console.log('token', token, 'parsedInput', parsedInput,\A            //         'regex', getParseRegexForToken(token, config));\A            if (parsedInput) {\A                skipped = string.substr(0, string.indexOf(parsedInput));\A                if (skipped.length > 0) {\A                    getParsingFlags(config).unusedInput.push(skipped);\A                }\A                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\A                totalParsedInputLength += parsedInput.length;\A            }\A            // don't parse if it's not a known token\A            if (formatTokenFunctions[token]) {\A                if (parsedInput) {\A                    getParsingFlags(config).empty = false;\A                }\A                else {\A                    getParsingFlags(config).unusedTokens.push(token);\A                }\A                addTimeToArrayFromToken(token, parsedInput, config);\A            }\A            else if (config._strict && !parsedInput) {\A                getParsingFlags(config).unusedTokens.push(token);\A            }\A        }\A\A        // add remaining unparsed input length to the string\A        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;\A        if (string.length > 0) {\A            getParsingFlags(config).unusedInput.push(string);\A        }\A\A        // clear _12h flag if hour is <= 12\A        if (config._a[HOUR] <= 12 &&\A            getParsingFlags(config).bigHour === true &&\A            config._a[HOUR] > 0) {\A            getParsingFlags(config).bigHour = undefined;\A        }\A\A        getParsingFlags(config).parsedDateParts = config._a.slice(0);\A        getParsingFlags(config).meridiem = config._meridiem;\A        // handle meridiem\A        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);\A\A        configFromArray(config);\A        checkOverflow(config);\A    }\A\A\A    function meridiemFixWrap (locale, hour, meridiem) {\A        var isPm;\A\A        if (meridiem == null) {\A            // nothing to do\A            return hour;\A        }\A        if (locale.meridiemHour != null) {\A            return locale.meridiemHour(hour, meridiem);\A        } else if (locale.isPM != null) {\A            // Fallback\A            isPm = locale.isPM(meridiem);\A            if (isPm && hour < 12) {\A                hour += 12;\A            }\A            if (!isPm && hour === 12) {\A                hour = 0;\A            }\A            return hour;\A        } else {\A            // this is not supposed to happen\A            return hour;\A        }\A    }\A\A    // date from string and array of format strings\A    function configFromStringAndArray(config) {\A        var tempConfig,\A            bestMoment,\A\A            scoreToBeat,\A            i,\A            currentScore;\A\A        if (config._f.length === 0) {\A            getParsingFlags(config).invalidFormat = true;\A            config._d = new Date(NaN);\A            return;\A        }\A\A        for (i = 0; i < config._f.length; i++) {\A            currentScore = 0;\A            tempConfig = copyConfig({}, config);\A            if (config._useUTC != null) {\A                tempConfig._useUTC = config._useUTC;\A            }\A            tempConfig._f = config._f[i];\A            configFromStringAndFormat(tempConfig);\A\A            if (!isValid(tempConfig)) {\A                continue;\A            }\A\A            // if there is any input that was not parsed add a penalty for that format\A            currentScore += getParsingFlags(tempConfig).charsLeftOver;\A\A            //or tokens\A            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\A\A            getParsingFlags(tempConfig).score = currentScore;\A\A            if (scoreToBeat == null || currentScore < scoreToBeat) {\A                scoreToBeat = currentScore;\A                bestMoment = tempConfig;\A            }\A        }\A\A        extend(config, bestMoment || tempConfig);\A    }\A\A    function configFromObject(config) {\A        if (config._d) {\A            return;\A        }\A\A        var i = normalizeObjectUnits(config._i);\A        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {\A            return obj && parseInt(obj, 10);\A        });\A\A        configFromArray(config);\A    }\A\A    function createFromConfig (config) {\A        var res = new Moment(checkOverflow(prepareConfig(config)));\A        if (res._nextDay) {\A            // Adding is smart enough around DST\A            res.add(1, 'd');\A            res._nextDay = undefined;\A        }\A\A        return res;\A    }\A\A    function prepareConfig (config) {\A        var input = config._i,\A            format = config._f;\A\A        config._locale = config._locale || getLocale(config._l);\A\A        if (input === null || (format === undefined && input === '')) {\A            return createInvalid({nullInput: true});\A        }\A\A        if (typeof input === 'string') {\A            config._i = input = config._locale.preparse(input);\A        }\A\A        if (isMoment(input)) {\A            return new Moment(checkOverflow(input));\A        } else if (isDate(input)) {\A            config._d = input;\A        } else if (isArray(format)) {\A            configFromStringAndArray(config);\A        } else if (format) {\A            configFromStringAndFormat(config);\A        }  else {\A            configFromInput(config);\A        }\A\A        if (!isValid(config)) {\A            config._d = null;\A        }\A\A        return config;\A    }\A\A    function configFromInput(config) {\A        var input = config._i;\A        if (isUndefined(input)) {\A            config._d = new Date(hooks.now());\A        } else if (isDate(input)) {\A            config._d = new Date(input.valueOf());\A        } else if (typeof input === 'string') {\A            configFromString(config);\A        } else if (isArray(input)) {\A            config._a = map(input.slice(0), function (obj) {\A                return parseInt(obj, 10);\A            });\A            configFromArray(config);\A        } else if (isObject(input)) {\A            configFromObject(config);\A        } else if (isNumber(input)) {\A            // from milliseconds\A            config._d = new Date(input);\A        } else {\A            hooks.createFromInputFallback(config);\A        }\A    }\A\A    function createLocalOrUTC (input, format, locale, strict, isUTC) {\A        var c = {};\A\A        if (locale === true || locale === false) {\A            strict = locale;\A            locale = undefined;\A        }\A\A        if ((isObject(input) && isObjectEmpty(input)) ||\A                (isArray(input) && input.length === 0)) {\A            input = undefined;\A        }\A        // object construction must be done this way.\A        // https://github.com/moment/moment/issues/1423\A        c._isAMomentObject = true;\A        c._useUTC = c._isUTC = isUTC;\A        c._l = locale;\A        c._i = input;\A        c._f = format;\A        c._strict = strict;\A\A        return createFromConfig(c);\A    }\A\A    function createLocal (input, format, locale, strict) {\A        return createLocalOrUTC(input, format, locale, strict, false);\A    }\A\A    var prototypeMin = deprecate(\A        'moment().min is deprecated,use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',\A        function () {\A            var other = createLocal.apply(null, arguments);\A            if (this.isValid() && other.isValid()) {\A                return other < this ? this : other;\A            } else {\A                return createInvalid();\A            }\A        }\A    );\A\A    var prototypeMax = deprecate(\A        'moment().max is deprecated,use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',\A        function () {\A            var other = createLocal.apply(null, arguments);\A            if (this.isValid() && other.isValid()) {\A                return other > this ? this : other;\A            } else {\A                return createInvalid();\A            }\A        }\A    );\A\A    // Pick a moment m from moments so that m[fn](other) is true for all\A    // other. This relies on the function fn to be transitive.\A    //\A    // moments should either be an array of moment objects or an array, whose\A    // first element is an array of moment objects.\A    function pickBy(fn, moments) {\A        var res, i;\A        if (moments.length === 1 && isArray(moments[0])) {\A            moments = moments[0];\A        }\A        if (!moments.length) {\A            return createLocal();\A        }\A        res = moments[0];\A        for (i = 1; i < moments.length; ++i) {\A            if (!moments[i].isValid() || moments[i][fn](res)) {\A                res = moments[i];\A            }\A        }\A        return res;\A    }\A\A    // TODO: Use [].sort instead?\A    function min () {\A        var args = [].slice.call(arguments, 0);\A\A        return pickBy('isBefore', args);\A    }\A\A    function max () {\A        var args = [].slice.call(arguments, 0);\A\A        return pickBy('isAfter', args);\A    }\A\A    var now = function () {\A        return Date.now ? Date.now() : +(new Date());\A    };\A\A    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];\A\A    function isDurationValid(m) {\A        for (var key in m) {\A            if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {\A                return false;\A            }\A        }\A\A        var unitHasDecimal = false;\A        for (var i = 0; i < ordering.length; ++i) {\A            if (m[ordering[i]]) {\A                if (unitHasDecimal) {\A                    return false; // only allow non-integers for smallest unit\A                }\A                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {\A                    unitHasDecimal = true;\A                }\A            }\A        }\A\A        return true;\A    }\A\A    function isValid$1() {\A        return this._isValid;\A    }\A\A    function createInvalid$1() {\A        return createDuration(NaN);\A    }\A\A    function Duration (duration) {\A        var normalizedInput = normalizeObjectUnits(duration),\A            years = normalizedInput.year || 0,\A            quarters = normalizedInput.quarter || 0,\A            months = normalizedInput.month || 0,\A            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,\A            days = normalizedInput.day || 0,\A            hours = normalizedInput.hour || 0,\A            minutes = normalizedInput.minute || 0,\A            seconds = normalizedInput.second || 0,\A            milliseconds = normalizedInput.millisecond || 0;\A\A        this._isValid = isDurationValid(normalizedInput);\A\A        // representation for dateAddRemove\A        this._milliseconds = +milliseconds +\A            seconds * 1e3 + // 1000\A            minutes * 6e4 + // 1000 * 60\A            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978\A        // Because of dateAddRemove treats 24 hours as different from a\A        // day when working around DST, we need to store them separately\A        this._days = +days +\A            weeks * 7;\A        // It is impossible to translate months into days without knowing\A        // which months you are are talking about, so we have to store\A        // it separately.\A        this._months = +months +\A            quarters * 3 +\A            years * 12;\A\A        this._data = {};\A\A        this._locale = getLocale();\A\A        this._bubble();\A    }\A\A    function isDuration (obj) {\A        return obj instanceof Duration;\A    }\A\A    function absRound (number) {\A        if (number < 0) {\A            return Math.round(-1 * number) * -1;\A        } else {\A            return Math.round(number);\A        }\A    }\A\A    // FORMATTING\A\A    function offset (token, separator) {\A        addFormatToken(token, 0, 0, function () {\A            var offset = this.utcOffset();\A            var sign = '+';\A            if (offset < 0) {\A                offset = -offset;\A                sign = '-';\A            }\A            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);\A        });\A    }\A\A    offset('Z', ':');\A    offset('ZZ', '');\A\A    // PARSING\A\A    addRegexToken('Z',  matchShortOffset);\A    addRegexToken('ZZ', matchShortOffset);\A    addParseToken(['Z', 'ZZ'], function (input, array, config) {\A        config._useUTC = true;\A        config._tzm = offsetFromString(matchShortOffset, input);\A    });\A\A    // HELPERS\A\A    // timezone chunker\A    // '+10:00' > ['10',  '00']\A    // '-1530'  > ['-15', '30']\A    var chunkOffset = /([\+\-]|\d\d)/gi;\A\A    function offsetFromString(matcher, string) {\A        var matches = (string || '').match(matcher);\A\A        if (matches === null) {\A            return null;\A        }\A\A        var chunk   = matches[matches.length - 1] || [];\A        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];\A        var minutes = +(parts[1] * 60) + toInt(parts[2]);\A\A        return minutes === 0 ?\A          0 :\A          parts[0] === '+' ? minutes : -minutes;\A    }\A\A    // Return a moment from input, that is local/utc/zone equivalent to model.\A    function cloneWithOffset(input, model) {\A        var res, diff;\A        if (model._isUTC) {\A            res = model.clone();\A            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();\A            // Use low-level api, because this fn is low-level api.\A            res._d.setTime(res._d.valueOf() + diff);\A            hooks.updateOffset(res, false);\A            return res;\A        } else {\A            return createLocal(input).local();\A        }\A    }\A\A    function getDateOffset (m) {\A        // On Firefox.24 Date#getTimezoneOffset returns a floating point.\A        // https://github.com/moment/moment/pull/1871\A        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;\A    }\A\A    // HOOKS\A\A    // This function will be called whenever a moment is mutated.\A    // It is intended to keep the offset in sync with the timezone.\A    hooks.updateOffset = function () {};\A\A    // MOMENTS\A\A    // keepLocalTime = true means only change the timezone, without\A    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->\A    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200,so we adjust the time as needed,to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case,then we have to adjust,because
// there is no such time in the given timezone.
function getSetOffset (input,keepLocalTime,keepMinutes){varoffset:this._offset || 0,localAdjust;ifthisisvalidreturninput:null ? this : NaN}if (input != null){iftypeofinput:== string) { input = offsetFromString(matchShortOffset,input);ifinput:== null) { return this}else if (Math.abs(input) < 16 && !keepMinutes){input:input * 60}if (!this._isUTC && keepLocalTime){localadjust:getDateOffset(this)}else if (!this._changeInProgress){this_changeinprogress:null}else{returnthis_isutcoffset:getDateOffset(this)}function getSetZone (input,keepLocalTime){ifinput:null) { if (typeof input !== 'string') { input = -input}function setOffsetToLocal (keepLocalTime){this_isutc:false}function setOffsetToParsedOffset (){ifthis_tzm:null) { this.utcOffset(this._tzm,false,true)}else if (typeof this._i === string){vartzone:offsetFromString(matchOffset,this._i);iftzone:null) { this.utcOffset(tZone)};
copyConfig(c,this);
c = prepareConfig(c);
if (c._a){varother:c._isUTC ? createUTC(c._a) : createLocal(c._a);this_isdstshifted:this.isValid() && compareArrays(c._a,other.toArray()) > 0}else{this_isdstshifted:false}function isLocal (){returnthisisvalidthis_isutc:false}function isUtcOffset (){returnthisisvalidthis_isutc:false}function isUtc (){returnthisisvalidthis_isutcthis_offset:== 0 : false}// ASP.NET json date format regex
var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;
// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
// somewhat more in line with 4.4.3.2 2004 spec,but allows decimal anywhere
// and further modified to allow for strings containing both week and day
var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function createDuration (input,key){varduration:input,// matching against regexp is expensive,do it on demand match = null,sign,ret,diffRes;ifisdurationinputduration:{ ms : input._milliseconds,d : input._days,M : input._months}else if (isNumber(input)){duration:{};
if (key){durationkey:input}else{durationmilliseconds:input}else if (!!(match = aspNetRegex.exec(input))){sign:(match[1] === '-') ? -1 : 1;duration:{ y : 0,d : toInt(match[DATE]) * sign,h : toInt(match[HOUR]) * sign,m : toInt(match[MINUTE]) * sign,s : toInt(match[SECOND]) * sign,ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match}else if (!!(match = isoRegex.exec(input))){sign:(match[1] === '-') ? -1 : 1;duration:{ y : parseIso(match[2],sign),M : parseIso(match[3],sign),w : parseIso(match[4],sign),d : parseIso(match[5],sign),h : parseIso(match[6],sign),m : parseIso(match[7],sign),s : parseIso(match[8],sign)}else if (duration == null){}else if (typeof duration === object && (from in duration || to in duration)){diffres:momentsDifference(createLocal(duration.from),createLocal(duration.to));duration:{}ret = new Duration(duration);
if (isDuration(input) && hasOwnProp(input,_locale)){ret_locale:input._locale}createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;
function parseIso (inp,sign){}function positiveMomentsDifference(base,other){varres:{}function momentsDifference(base,other){ifbaseisvalidotherisvalidreturnmilliseconds:0,months: 0}other = cloneWithOffset(other,base);
if (base.isBefore(other)){res:positiveMomentsDifference(base,other)}else{res:positiveMomentsDifference(other,base);resmilliseconds:-res.milliseconds;resmonths:-res.months}// TODO: remove name arg after deprecation is removed
function createAdder(direction,name){tmp:val;val:period;period:tmp}function addSubtract (mom,duration,isAdding,updateOffset){varmilliseconds:duration._milliseconds,days = absRound(duration._days),months = absRound(duration._months)}var add = createAdder(1,add);
var subtract = createAdder(-1,subtract);
function getCalendarFormat(myMoment,now){vardiff:myMoment.diff(now,'days',true);returndiff-6sameelse:diff < -1 ? lastWeek : diff < 0 ? lastDay : diff < 1 ? sameDay : diff < 2 ? nextDay : diff < 7 ? nextWeek : sameElse}function calendar$1 (time,formats){varoutput:formats && (isFunction(formats[format]) ? formats[format].call(this,now) : formats[format])}function isAfter (input,units){varlocalinput:isMoment(input) ? input : createLocal(input)}function isBefore (input,units){varlocalinput:isMoment(input) ? input : createLocal(input)}function isBetween (from,to,units,inclusivity){varlocalfrom:isMoment(from) ? from : createLocal(from),localTo = isMoment(to) ? to : createLocal(to)}function isSame (input,units){varlocalinput:isMoment(input) ? input : createLocal(input),inputMs}units = normalizeUnits(units) || millisecond;
if (units === millisecond){returnthisvalueof:== localInput.valueOf()}else{inputms:localInput.valueOf();returnthisclonestartofunitsvalueof:inputMs && inputMs <= this.clone().endOf(units).valueOf()}zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
units = normalizeUnits(units);
switch (units){caseyear:output = monthDiff(this,that) / 12;casemonth:output = monthDiff(this,that);casequarter:output = monthDiff(this,that) / 3;casesecond:output = (this - that) / 1000}function monthDiff (a,b){ifb-anchor0anchor2:a.clone().add(wholeMonthDiff - 1,'months')}else{anchor2:a.clone().add(wholeMonthDiff + 1,'months')}hooks.defaultFormat = YYYY-MM-DDTHH:mm:ssZ;
hooks.defaultFormatUtc = YYYY-MM-DDTHH:mm:ss[Z];
function toString (){returnthisclonelocaleenformatdddmmmddyyyyhh:mm:ss [GMT]ZZ');\A }\A\A function toISOString(keepOffset) {\A if (!this.isValid()) {\A return null;\A }\A var utc = keepOffset !== true;\A var m = utc ? this.clone().utc() : this;\A if (m.year() < 0 || m.year() > 9999) {\A return formatMoment(m,utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');\A }\A if (isFunction(Date.prototype.toISOString)) {\A // native implementation is ~50x faster,use it when we can\A if (utc) {\A return this.toDate().toISOString();\A } else {\A return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z',formatMoment(m,'Z'));\A }\A }\A return formatMoment(m,utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');\A }\A\A /**\A * Return a human readable representation of a moment that can\A * also be evaluated to get a new moment which is the same\A *\A * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects\A */\A function inspect () {\A if (!this.isValid()) {\A return 'moment.invalid(/* ' + this._i + ' */)';\A }\A var func = 'moment';\A var zone = '';\A if (!this.isLocal()) {\A func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';\A zone = 'Z';\A }\A var prefix = '[' + func + '("]';\A var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';\A var datetime = '-MM-DD[T]HH:mm:ss.SSS';\A var suffix = zone + '[")]';\A\A return this.format(prefix + year + datetime + suffix);\A }\A\A function format (inputString) {\A if (!inputString) {\A inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;\A }\A var output = formatMoment(this,inputString);\A return this.localeData().postformat(output);\A }\A\A function from (time,withoutSuffix) {\A if (this.isValid() &&\A ((isMoment(time) && time.isValid()) ||\A createLocal(time).isValid())) {\A return createDuration({to: this,from: time}).locale(this.locale()).humanize(!withoutSuffix);\A } else {\A return this.localeData().invalidDate();\A }\A }\A\A function fromNow (withoutSuffix) {\A return this.from(createLocal(),withoutSuffix);\A }\A\A function to (time,withoutSuffix) {\A if (this.isValid() &&\A ((isMoment(time) && time.isValid()) ||\A createLocal(time).isValid())) {\A return createDuration({from: this,to: time}).locale(this.locale()).humanize(!withoutSuffix);\A } else {\A return this.localeData().invalidDate();\A }\A }\A\A function toNow (withoutSuffix) {\A return this.to(createLocal(),withoutSuffix);\A }\A\A // If passed a locale key,it will set the locale for this\A // instance. Otherwise,it will return the locale configuration\A // variables for this instance.\A function locale (key) {\A var newLocaleData;\A\A if (key === undefined) {\A return this._locale._abbr;\A } else {\A newLocaleData = getLocale(key);\A if (newLocaleData != null) {\A this._locale = newLocaleData;\A }\A return this;\A }\A }\A\A var lang = deprecate(\A 'moment().lang() is deprecated. Instead,use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',\A function (key) {\A if (key === undefined) {\A return this.localeData();\A } else {\A return this.locale(key);\A }\A }\A );\A\A function localeData () {\A return this._locale;\A }\A\A var MS_PER_SECOND = 1000;\A var MS_PER_MINUTE = 60 * MS_PER_SECOND;\A var MS_PER_HOUR = 60 * MS_PER_MINUTE;\A var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;\A\A // actual modulo - handles negative numbers (for dates before 1970):\A function mod$1(dividend,divisor) {\A return (dividend % divisor + divisor) % divisor;\A }\A\A function localStartOfDate(y,m,d) {\A // the date constructor remaps years 0-99 to 1900-1999\A if (y < 100 && y >= 0) {\A // preserve leap years using a full 400 year cycle,then reset\A return new Date(y + 400,m,d) - MS_PER_400_YEARS;\A } else {\A return new Date(y,m,d).valueOf();\A }\A }\A\A function utcStartOfDate(y,m,d) {\A // Date.UTC remaps years 0-99 to 1900-1999\A if (y < 100 && y >= 0) {\A // preserve leap years using a full 400 year cycle,then reset\A return Date.UTC(y + 400,m,d) - MS_PER_400_YEARS;\A } else {\A return Date.UTC(y,m,d);\A }\A }\A\A function startOf (units) {\A var time;\A units = normalizeUnits(units);\A if (units === undefined || units === 'millisecond' || !this.isValid()) {\A return this;\A }\A\A var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;\A\A switch (units) {\A case 'year':\A time = startOfDate(this.year(),0,1);\A break;\A case 'quarter':\A time = startOfDate(this.year(),this.month() - this.month() % 3,1);\A break;\A case 'month':\A time = startOfDate(this.year(),this.month(),1);\A break;\A case 'week':\A time = startOfDate(this.year(),this.month(),this.date() - this.weekday());\A break;\A case 'isoWeek':\A time = startOfDate(this.year(),this.month(),this.date() - (this.isoWeekday() - 1));\A break;\A case 'day':\A case 'date':\A time = startOfDate(this.year(),this.month(),this.date());\A break;\A case 'hour':\A time = this._d.valueOf();\A time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),MS_PER_HOUR);\A break;\A case 'minute':\A time = this._d.valueOf();\A time -= mod$1(time,MS_PER_MINUTE);\A break;\A case 'second':\A time = this._d.valueOf();\A time -= mod$1(time,MS_PER_SECOND);\A break;\A }\A\A this._d.setTime(time);\A hooks.updateOffset(this,true);\A return this;\A }\A\A function endOf (units) {\A var time;\A units = normalizeUnits(units);\A if (units === undefined || units === 'millisecond' || !this.isValid()) {\A return this;\A }\A\A var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;\A\A switch (units) {\A case 'year':\A time = startOfDate(this.year() + 1,0,1) - 1;\A break;\A case 'quarter':\A time = startOfDate(this.year(),this.month() - this.month() % 3 + 3,1) - 1;\A break;\A case 'month':\A time = startOfDate(this.year(),this.month() + 1,1) - 1;\A break;\A case 'week':\A time = startOfDate(this.year(),this.month(),this.date() - this.weekday() + 7) - 1;\A break;\A case 'isoWeek':\A time = startOfDate(this.year(),this.month(),this.date() - (this.isoWeekday() - 1) + 7) - 1;\A break;\A case 'day':\A case 'date':\A time = startOfDate(this.year(),this.month(),this.date() + 1) - 1;\A break;\A case 'hour':\A time = this._d.valueOf();\A time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),MS_PER_HOUR) - 1;\A break;\A case 'minute':\A time = this._d.valueOf();\A time += MS_PER_MINUTE - mod$1(time,MS_PER_MINUTE) - 1;\A break;\A case 'second':\A time = this._d.valueOf();\A time += MS_PER_SECOND - mod$1(time,MS_PER_SECOND) - 1;\A break;\A }\A\A this._d.setTime(time);\A hooks.updateOffset(this,true);\A return this;\A }\A\A function valueOf () {\A return this._d.valueOf() - ((this._offset || 0) * 60000);\A }\A\A function unix () {\A return Math.floor(this.valueOf() / 1000);\A }\A\A function toDate () {\A return new Date(this.valueOf());\A }\A\A function toArray () {\A var m = this;\A return [m.year(),m.month(),m.date(),m.hour(),m.minute(),m.second(),m.millisecond()];\A }\A\A function toObject () {\A var m = this;\A return {\A years: m.year(),\A months: m.month(),\A date: m.date(),\A hours: m.hours(),\A minutes: m.minutes(),\A seconds: m.seconds(),\A milliseconds: m.milliseconds()\A };\A }\A\A function toJSON () {\A // new Date(NaN).toJSON() === null\A return this.isValid() ? this.toISOString() : null;\A }\A\A function isValid$2 () {\A return isValid(this);\A }\A\A function parsingFlags () {\A return extend({},getParsingFlags(this));\A }\A\A function invalidAt () {\A return getParsingFlags(this).overflow;\A }\A\A function creationData() {\A return {\A input: this._i,\A format: this._f,\A locale: this._locale,\A isUTC: this._isUTC,\A strict: this._strict\A };\A }\A\A // FORMATTING\A\A addFormatToken(0,['gg',2],0,function () {\A return this.weekYear() % 100;\A });\A\A addFormatToken(0,['GG',2],0,function () {\A return this.isoWeekYear() % 100;\A });\A\A function addWeekYearFormatToken (token,getter) {\A addFormatToken(0,[token,token.length],0,getter);\A }\A\A addWeekYearFormatToken('gggg','weekYear');\A addWeekYearFormatToken('ggggg','weekYear');\A addWeekYearFormatToken('GGGG','isoWeekYear');\A addWeekYearFormatToken('GGGGG','isoWeekYear');\A\A // ALIASES\A\A addUnitAlias('weekYear','gg');\A addUnitAlias('isoWeekYear','GG');\A\A // PRIORITY\A\A addUnitPriority('weekYear',1);\A addUnitPriority('isoWeekYear',1);\A\A\A // PARSING\A\A addRegexToken('G',matchSigned);\A addRegexToken('g',matchSigned);\A addRegexToken('GG',match1to2,match2);\A addRegexToken('gg',match1to2,match2);\A addRegexToken('GGGG',match1to4,match4);\A addRegexToken('gggg',match1to4,match4);\A addRegexToken('GGGGG',match1to6,match6);\A addRegexToken('ggggg',match1to6,match6);\A\A addWeekParseToken(['gggg','ggggg','GGGG','GGGGG'],function (input,week,config,token) {\A week[token.substr(0,2)] = toInt(input);\A });\A\A addWeekParseToken(['gg','GG'],function (input,week,config,token) {\A week[token] = hooks.parseTwoDigitYear(input);\A });\A\A // MOMENTS\A\A function getSetWeekYear (input) {\A return getSetWeekYearHelper.call(this,\A input,\A this.week(),\A this.weekday(),\A this.localeData()._week.dow,\A this.localeData()._week.doy);\A }\A\A function getSetISOWeekYear (input) {\A return getSetWeekYearHelper.call(this,\A input,this.isoWeek(),this.isoWeekday(),1,4);\A }\A\A function getISOWeeksInYear () {\A return weeksInYear(this.year(),1,4);\A }\A\A function getWeeksInYear () {\A var weekInfo = this.localeData()._week;\A return weeksInYear(this.year(),weekInfo.dow,weekInfo.doy);\A }\A\A function getSetWeekYearHelper(input,week,weekday,dow,doy) {\A var weeksTarget;\A if (input == null) {\A return weekOfYear(this,dow,doy).year;\A } else {\A weeksTarget = weeksInYear(input,dow,doy);\A if (week > weeksTarget) {\A week = weeksTarget;\A }\A return setWeekAll.call(this,input,week,weekday,dow,doy);\A }\A }\A\A function setWeekAll(weekYear,week,weekday,dow,doy) {\A var dayOfYearData = dayOfYearFromWeeks(weekYear,week,weekday,dow,doy),\A date = createUTCDate(dayOfYearData.year,0,dayOfYearData.dayOfYear);\A\A this.year(date.getUTCFullYear());\A this.month(date.getUTCMonth());\A this.date(date.getUTCDate());\A return this;\A }\A\A // FORMATTING\A\A addFormatToken('Q',0,'Qo','quarter');\A\A // ALIASES\A\A addUnitAlias('quarter','Q');\A\A // PRIORITY\A\A addUnitPriority('quarter',7);\A\A // PARSING\A\A addRegexToken('Q',match1);\A addParseToken('Q',function (input,array) {\A array[MONTH] = (toInt(input) - 1) * 3;\A });\A\A // MOMENTS\A\A function getSetQuarter (input) {\A return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);\A }\A\A // FORMATTING\A\A addFormatToken('D',['DD',2],'Do','date');\A\A // ALIASES\A\A addUnitAlias('date','D');\A\A // PRIORITY\A addUnitPriority('date',9);\A\A // PARSING\A\A addRegexToken('D',match1to2);\A addRegexToken('DD',match1to2,match2);\A addRegexToken('Do',function (isStrict,locale) {\A // TODO: Remove "ordinalParse" fallback in next major release.\A return isStrict ?\A (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :\A locale._dayOfMonthOrdinalParseLenient;\A });\A\A addParseToken(['D','DD'],DATE);\A addParseToken('Do',function (input,array) {\A array[DATE] = toInt(input.match(match1to2)[0]);\A });\A\A // MOMENTS\A\A var getSetDayOfMonth = makeGetSet('Date',true);\A\A // FORMATTING\A\A addFormatToken('DDD',['DDDD',3],'DDDo','dayOfYear');\A\A // ALIASES\A\A addUnitAlias('dayOfYear','DDD');\A\A // PRIORITY\A addUnitPriority('dayOfYear',4);\A\A // PARSING\A\A addRegexToken('DDD',match1to3);\A addRegexToken('DDDD',match3);\A addParseToken(['DDD','DDDD'],function (input,array,config) {\A config._dayOfYear = toInt(input);\A });\A\A // HELPERS\A\A // MOMENTS\A\A function getSetDayOfYear (input) {\A var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;\A return input == null ? dayOfYear : this.add((input - dayOfYear),'d');\A }\A\A // FORMATTING\A\A addFormatToken('m',['mm',2],0,'minute');\A\A // ALIASES\A\A addUnitAlias('minute','m');\A\A // PRIORITY\A\A addUnitPriority('minute',14);\A\A // PARSING\A\A addRegexToken('m',match1to2);\A addRegexToken('mm',match1to2,match2);\A addParseToken(['m','mm'],MINUTE);\A\A // MOMENTS\A\A var getSetMinute = makeGetSet('Minutes',false);\A\A // FORMATTING\A\A addFormatToken('s',['ss',2],0,'second');\A\A // ALIASES\A\A addUnitAlias('second','s');\A\A // PRIORITY\A\A addUnitPriority('second',15);\A\A // PARSING\A\A addRegexToken('s',match1to2);\A addRegexToken('ss',match1to2,match2);\A addParseToken(['s','ss'],SECOND);\A\A // MOMENTS\A\A var getSetSecond = makeGetSet('Seconds',false);\A\A // FORMATTING\A\A addFormatToken('S',0,0,function () {\A return ~~(this.millisecond() / 100);\A });\A\A addFormatToken(0,['SS',2],0,function () {\A return ~~(this.millisecond() / 10);\A });\A\A addFormatToken(0,['SSS',3],0,'millisecond');\A addFormatToken(0,['SSSS',4],0,function () {\A return this.millisecond() * 10;\A });\A addFormatToken(0,['SSSSS',5],0,function () {\A return this.millisecond() * 100;\A });\A addFormatToken(0,['SSSSSS',6],0,function () {\A return this.millisecond() * 1000;\A });\A addFormatToken(0,['SSSSSSS',7],0,function () {\A return this.millisecond() * 10000;\A });\A addFormatToken(0,['SSSSSSSS',8],0,function () {\A return this.millisecond() * 100000;\A });\A addFormatToken(0,['SSSSSSSSS',9],0,function () {\A return this.millisecond() * 1000000;\A });\A\A\A // ALIASES\A\A addUnitAlias('millisecond','ms');\A\A // PRIORITY\A\A addUnitPriority('millisecond',16);\A\A // PARSING\A\A addRegexToken('S',match1to3,match1);\A addRegexToken('SS',match1to3,match2);\A addRegexToken('SSS',match1to3,match3);\A\A var token;\A for (token = 'SSSS'; token.length <= 9; token += 'S') {\A addRegexToken(token,matchUnsigned);\A }\A\A function parseMs(input,array) {\A array[MILLISECOND] = toInt(('0.' + input) * 1000);\A }\A\A for (token = 'S'; token.length <= 9; token += 'S') {\A addParseToken(token,parseMs);\A }\A // MOMENTS\A\A var getSetMillisecond = makeGetSet('Milliseconds',false);\A\A // FORMATTING\A\A addFormatToken('z',0,0,'zoneAbbr');\A addFormatToken('zz',0,0,'zoneName');\A\A // MOMENTS\A\A function getZoneAbbr () {\A return this._isUTC ? 'UTC' : '';\A }\A\A function getZoneName () {\A return this._isUTC ? 'Coordinated Universal Time' : '';\A }\A\A var proto = Moment.prototype;\A\A proto.add = add;\A proto.calendar = calendar$1;\A proto.clone = clone;\A proto.diff = diff;\A proto.endOf = endOf;\A proto.format = format;\A proto.from = from;\A proto.fromNow = fromNow;\A proto.to = to;\A proto.toNow = toNow;\A proto.get = stringGet;\A proto.invalidAt = invalidAt;\A proto.isAfter = isAfter;\A proto.isBefore = isBefore;\A proto.isBetween = isBetween;\A proto.isSame = isSame;\A proto.isSameOrAfter = isSameOrAfter;\A proto.isSameOrBefore = isSameOrBefore;\A proto.isValid = isValid$2;\A proto.lang = lang;\A proto.locale = locale;\A proto.localeData = localeData;\A proto.max = prototypeMax;\A proto.min = prototypeMin;\A proto.parsingFlags = parsingFlags;\A proto.set = stringSet;\A proto.startOf = startOf;\A proto.subtract = subtract;\A proto.toArray = toArray;\A proto.toObject = toObject;\A proto.toDate = toDate;\A proto.toISOString = toISOString;\A proto.inspect = inspect;\A proto.toJSON = toJSON;\A proto.toString = toString;\A proto.unix = unix;\A proto.valueOf = valueOf;\A proto.creationData = creationData;\A proto.year = getSetYear;\A proto.isLeapYear = getIsLeapYear;\A proto.weekYear = getSetWeekYear;\A proto.isoWeekYear = getSetISOWeekYear;\A proto.quarter = proto.quarters = getSetQuarter;\A proto.month = getSetMonth;\A proto.daysInMonth = getDaysInMonth;\A proto.week = proto.weeks = getSetWeek;\A proto.isoWeek = proto.isoWeeks = getSetISOWeek;\A proto.weeksInYear = getWeeksInYear;\A proto.isoWeeksInYear = getISOWeeksInYear;\A proto.date = getSetDayOfMonth;\A proto.day = proto.days = getSetDayOfWeek;\A proto.weekday = getSetLocaleDayOfWeek;\A proto.isoWeekday = getSetISODayOfWeek;\A proto.dayOfYear = getSetDayOfYear;\A proto.hour = proto.hours = getSetHour;\A proto.minute = proto.minutes = getSetMinute;\A proto.second = proto.seconds = getSetSecond;\A proto.millisecond = proto.milliseconds = getSetMillisecond;\A proto.utcOffset = getSetOffset;\A proto.utc = setOffsetToUTC;\A proto.local = setOffsetToLocal;\A proto.parseZone = setOffsetToParsedOffset;\A proto.hasAlignedHourOffset = hasAlignedHourOffset;\A proto.isDST = isDaylightSavingTime;\A proto.isLocal = isLocal;\A proto.isUtcOffset = isUtcOffset;\A proto.isUtc = isUtc;\A proto.isUTC = isUtc;\A proto.zoneAbbr = getZoneAbbr;\A proto.zoneName = getZoneName;\A proto.dates = deprecate('dates accessor is deprecated. Use date instead.',getSetDayOfMonth);\A proto.months = deprecate('months accessor is deprecated. Use month instead',getSetMonth);\A proto.years = deprecate('years accessor is deprecated. Use year instead',getSetYear);\A proto.zone = deprecate('moment().zone is deprecated,use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',getSetZone);\A proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',isDaylightSavingTimeShifted);\A\A function createUnix (input) {\A return createLocal(input * 1000);\A }\A\A function createInZone () {\A return createLocal.apply(null,arguments).parseZone();\A }\A\A function preParsePostFormat (string) {\A return string;\A }\A\A var proto$1 = Locale.prototype;\A\A proto$1.calendar = calendar;\A proto$1.longDateFormat = longDateFormat;\A proto$1.invalidDate = invalidDate;\A proto$1.ordinal = ordinal;\A proto$1.preparse = preParsePostFormat;\A proto$1.postformat = preParsePostFormat;\A proto$1.relativeTime = relativeTime;\A proto$1.pastFuture = pastFuture;\A proto$1.set = set;\A\A proto$1.months = localeMonths;\A proto$1.monthsShort = localeMonthsShort;\A proto$1.monthsParse = localeMonthsParse;\A proto$1.monthsRegex = monthsRegex;\A proto$1.monthsShortRegex = monthsShortRegex;\A proto$1.week = localeWeek;\A proto$1.firstDayOfYear = localeFirstDayOfYear;\A proto$1.firstDayOfWeek = localeFirstDayOfWeek;\A\A proto$1.weekdays = localeWeekdays;\A proto$1.weekdaysMin = localeWeekdaysMin;\A proto$1.weekdaysShort = localeWeekdaysShort;\A proto$1.weekdaysParse = localeWeekdaysParse;\A\A proto$1.weekdaysRegex = weekdaysRegex;\A proto$1.weekdaysShortRegex = weekdaysShortRegex;\A proto$1.weekdaysMinRegex = weekdaysMinRegex;\A\A proto$1.isPM = localeIsPM;\A proto$1.meridiem = localeMeridiem;\A\A function get$1 (format,index,field,setter) {\A var locale = getLocale();\A var utc = createUTC().set(setter,index);\A return locale[field](utc,format);\A }\A\A function listMonthsImpl (format,index,field) {\A if (isNumber(format)) {\A index = format;\A format = undefined;\A }\A\A format = format || '';\A\A if (index != null) {\A return get$1(format,index,field,'month');\A }\A\A var i;\A var out = [];\A for (i = 0; i < 12; i++) {\A out[i] = get$1(format,i,field,'month');\A }\A return out;\A }\A\A // ()\A // (5)\A // (fmt,5)\A // (fmt)\A // (true)\A // (true,5)\A // (true,fmt,5)\A // (true,fmt)\A function listWeekdaysImpl (localeSorted,format,index,field) {\A if (typeof localeSorted === 'boolean') {\A if (isNumber(format)) {\A index = format;\A format = undefined;\A }\A\A format = format || '';\A } else {\A format = localeSorted;\A index = format;\A localeSorted = false;\A\A if (isNumber(format)) {\A index = format;\A format = undefined;\A }\A\A format = format || '';\A }\A\A var locale = getLocale(),\A shift = localeSorted ? locale._week.dow : 0;\A\A if (index != null) {\A return get$1(format,(index + shift) % 7,field,'day');\A }\A\A var i;\A var out = [];\A for (i = 0; i < 7; i++) {\A out[i] = get$1(format,(i + shift) % 7,field,'day');\A }\A return out;\A }\A\A function listMonths (format,index) {\A return listMonthsImpl(format,index,'months');\A }\A\A function listMonthsShort (format,index) {\A return listMonthsImpl(format,index,'monthsShort');\A }\A\A function listWeekdays (localeSorted,format,index) {\A return listWeekdaysImpl(localeSorted,format,index,'weekdays');\A }\A\A function listWeekdaysShort (localeSorted,format,index) {\A return listWeekdaysImpl(localeSorted,format,index,'weekdaysShort');\A }\A\A function listWeekdaysMin (localeSorted,format,index) {\A return listWeekdaysImpl(localeSorted,format,index,'weekdaysMin');\A }\A\A getSetGlobalLocale('en',{\A dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,\A ordinal : function (number) {\A var b = number % 10,\A output = (toInt(number % 100 / 10) === 1) ? 'th' :\A (b === 1) ? 'st' :\A (b === 2) ? 'nd' :\A (b === 3) ? 'rd' : 'th';\A return number + output;\A }\A });\A\A // Side effect imports\A\A hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.',getSetGlobalLocale);\A hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.',getLocale);\A\A var mathAbs = Math.abs;\A\A function abs () {\A var data = this._data;\A\A this._milliseconds = mathAbs(this._milliseconds);\A this._days = mathAbs(this._days);\A this._months = mathAbs(this._months);\A\A data.milliseconds = mathAbs(data.milliseconds);\A data.seconds = mathAbs(data.seconds);\A data.minutes = mathAbs(data.minutes);\A data.hours = mathAbs(data.hours);\A data.months = mathAbs(data.months);\A data.years = mathAbs(data.years);\A\A return this;\A }\A\A function addSubtract$1 (duration,input,value,direction) {\A var other = createDuration(input,value);\A\A duration._milliseconds += direction * other._milliseconds;\A duration._days += direction * other._days;\A duration._months += direction * other._months;\A\A return duration._bubble();\A }\A\A // supports only 2.0-style add(1,'s') or add(duration)\A function add$1 (input,value) {\A return addSubtract$1(this,input,value,1);\A }\A\A // supports only 2.0-style subtract(1,'s') or subtract(duration)\A function subtract$1 (input,value) {\A return addSubtract$1(this,input,value,-1);\A }\A\A function absCeil (number) {\A if (number < 0) {\A return Math.floor(number);\A } else {\A return Math.ceil(number);\A }\A }\A\A function bubble () {\A var milliseconds = this._milliseconds;\A var days = this._days;\A var months = this._months;\A var data = this._data;\A var seconds,minutes,hours,years,monthsFromDays;\A\A // if we have a mix of positive and negative values,bubble down first\A // check: https://github.com/moment/moment/issues/2166\A if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||\A (milliseconds <= 0 && days <= 0 && months <= 0))) {\A milliseconds += absCeil(monthsToDays(months) + days) * 864e5;\A days = 0;\A months = 0;\A }\A\A // The following code bubbles up values,see the tests for\A // examples of what that means.\A data.milliseconds = milliseconds % 1000;\A\A seconds = absFloor(milliseconds / 1000);\A data.seconds = seconds % 60;\A\A minutes = absFloor(seconds / 60);\A data.minutes = minutes % 60;\A\A hours = absFloor(minutes / 60);\A data.hours = hours % 24;\A\A days += absFloor(hours / 24);\A\A // convert days to months\A monthsFromDays = absFloor(daysToMonths(days));\A months += monthsFromDays;\A days -= absCeil(monthsToDays(monthsFromDays));\A\A // 12 months -> 1 year\A years = absFloor(months / 12);\A months %= 12;\A\A data.days = days;\A data.months = months;\A data.years = years;\A\A return this;\A }\A\A function daysToMonths (days) {\A // 400 years have 146097 days (taking into account leap year rules)\A // 400 years have 12 months === 4800\A return days * 4800 / 146097;\A }\A\A function monthsToDays (months) {\A // the reverse of daysToMonths\A return months * 146097 / 4800;\A }\A\A function as (units) {\A if (!this.isValid()) {\A return NaN;\A }\A var days;\A var months;\A var milliseconds = this._milliseconds;\A\A units = normalizeUnits(units);\A\A if (units === 'month' || units === 'quarter' || units === 'year') {\A days = this._days + milliseconds / 864e5;\A months = this._months + daysToMonths(days);\A switch (units) {\A case 'month': return months;\A case 'quarter': return months / 3;\A case 'year': return months / 12;\A }\A } else {\A // handle milliseconds separately because of floating point math errors (issue #1867)\A days = this._days + Math.round(monthsToDays(this._months));\A switch (units) {\A case 'week' : return days / 7 + milliseconds / 6048e5;\A case 'day' : return days + milliseconds / 864e5;\A case 'hour' : return days * 24 + milliseconds / 36e5;\A case 'minute' : return days * 1440 + milliseconds / 6e4;\A case 'second' : return days * 86400 + milliseconds / 1000;\A // Math.floor prevents floating point math errors here\A case 'millisecond': return Math.floor(days * 864e5) + milliseconds;\A default: throw new Error('Unknown unit ' + units);\A }\A }\A }\A\A // TODO: Use this.as('ms')?\A function valueOf$1 () {\A if (!this.isValid()) {\A return NaN;\A }\A return (\A this._milliseconds +\A this._days * 864e5 +\A (this._months % 12) * 2592e6 +\A toInt(this._months / 12) * 31536e6\A );\A }\A\A function makeAs (alias) {\A return function () {\A return this.as(alias);\A };\A }\A\A var asMilliseconds = makeAs('ms');\A var asSeconds = makeAs('s');\A var asMinutes = makeAs('m');\A var asHours = makeAs('h');\A var asDays = makeAs('d');\A var asWeeks = makeAs('w');\A var asMonths = makeAs('M');\A var asQuarters = makeAs('Q');\A var asYears = makeAs('y');\A\A function clone$1 () {\A return createDuration(this);\A }\A\A function get$2 (units) {\A units = normalizeUnits(units);\A return this.isValid() ? this[units + 's']() : NaN;\A }\A\A function makeGetter(name) {\A return function () {\A return this.isValid() ? this._data[name] : NaN;\A };\A }\A\A var milliseconds = makeGetter('milliseconds');\A var seconds = makeGetter('seconds');\A var minutes = makeGetter('minutes');\A var hours = makeGetter('hours');\A var days = makeGetter('days');\A var months = makeGetter('months');\A var years = makeGetter('years');\A\A function weeks () {\A return absFloor(this.days() / 7);\A }\A\A var round = Math.round;\A var thresholds = {\A ss: 44,// a few seconds to seconds\A s : 45,// seconds to minute\A m : 45,// minutes to hour\A h : 22,// hours to day\A d : 26,// days to month\A M : 11 // months to year\A };\A\A // helper function for moment.fn.from,moment.fn.fromNow,and moment.duration.fn.humanize\A function substituteTimeAgo(string,number,withoutSuffix,isFuture,locale) {\A return locale.relativeTime(number || 1,!!withoutSuffix,string,isFuture);\A }\A\A function relativeTime$1 (posNegDuration,withoutSuffix,locale) {\A var duration = createDuration(posNegDuration).abs();\A var seconds = round(duration.as('s'));\A var minutes = round(duration.as('m'));\A var hours = round(duration.as('h'));\A var days = round(duration.as('d'));\A var months = round(duration.as('M'));\A var years = round(duration.as('y'));\A\A var a = seconds <= thresholds.ss && ['s',seconds] ||\A seconds < thresholds.s && ['ss',seconds] ||\A minutes <= 1 && ['m'] ||\A minutes < thresholds.m && ['mm',minutes] ||\A hours <= 1 && ['h'] ||\A hours < thresholds.h && ['hh',hours] ||\A days <= 1 && ['d'] ||\A days < thresholds.d && ['dd',days] ||\A months <= 1 && ['M'] ||\A months < thresholds.M && ['MM',months] ||\A years <= 1 && ['y'] || ['yy',years];\A\A a[2] = withoutSuffix;\A a[3] = +posNegDuration > 0;\A a[4] = locale;\A return substituteTimeAgo.apply(null,a);\A }\A\A // This function allows you to set the rounding function for relative time strings\A function getSetRelativeTimeRounding (roundingFunction) {\A if (roundingFunction === undefined) {\A return round;\A }\A if (typeof(roundingFunction) === 'function') {\A round = roundingFunction;\A return true;\A }\A return false;\A }\A\A // This function allows you to set a threshold for relative time strings\A function getSetRelativeTimeThreshold (threshold,limit) {\A if (thresholds[threshold] === undefined) {\A return false;\A }\A if (limit === undefined) {\A return thresholds[threshold];\A }\A thresholds[threshold] = limit;\A if (threshold === 's') {\A thresholds.ss = limit - 1;\A }\A return true;\A }\A\A function humanize (withSuffix) {\A if (!this.isValid()) {\A return this.localeData().invalidDate();\A }\A\A var locale = this.localeData();\A var output = relativeTime$1(this,!withSuffix,locale);\A\A if (withSuffix) {\A output = locale.pastFuture(+this,output);\A }\A\A return locale.postformat(output);\A }\A\A var abs$1 = Math.abs;\A\A function sign(x) {\A return ((x > 0) - (x < 0)) || +x;\A }\A\A function toISOString$1() {\A // for ISO strings we do not use the normal bubbling rules:\A // * milliseconds bubble up until they become hours\A // * days do not bubble at all\A // * months bubble up until they become years\A // This is because there is no context-free conversion between hours and days\A // (think of clock changes)\A // and also not between days and months (28-31 days per month)\A if (!this.isValid()) {\A return this.localeData().invalidDate();\A }\A\A var seconds = abs$1(this._milliseconds) / 1000;\A var days = abs$1(this._days);\A var months = abs$1(this._months);\A var minutes,hours,years;\A\A // 3600 seconds -> 60 minutes -> 1 hour\A minutes = absFloor(seconds / 60);\A hours = absFloor(minutes / 60);\A seconds %= 60;\A minutes %= 60;\A\A // 12 months -> 1 year\A years = absFloor(months / 12);\A months %= 12;\A\A\A // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\A var Y = years;\A var M = months;\A var D = days;\A var h = hours;\A var m = minutes;\A var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/,'') : '';\A var total = this.asSeconds();\A\A if (!total) {\A // this is the same as C#'s (Noda) and python (isodate)... // but not other JS (goog.date) return P0D}var proto$2 = Duration.prototype;
proto$2.isValid = isValid$1;
proto$2.abs = abs;
proto$2.add = add$1;
proto$2.subtract = subtract$1;
proto$2.as = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds = asSeconds;
proto$2.asMinutes = asMinutes;
proto$2.asHours = asHours;
proto$2.asDays = asDays;
proto$2.asWeeks = asWeeks;
proto$2.asMonths = asMonths;
proto$2.asQuarters = asQuarters;
proto$2.asYears = asYears;
proto$2.valueOf = valueOf$1;
proto$2._bubble = bubble;
proto$2.clone = clone$1;
proto$2.get = get$2;
proto$2.milliseconds = milliseconds;
proto$2.seconds = seconds;
proto$2.minutes = minutes;
proto$2.hours = hours;
proto$2.days = days;
proto$2.weeks = weeks;
proto$2.months = months;
proto$2.years = years;
proto$2.humanize = humanize;
proto$2.toISOString = toISOString$1;
proto$2.toString = toISOString$1;
proto$2.toJSON = toISOString$1;
proto$2.locale = locale;
proto$2.localeData = localeData;
proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',toISOString$1);
proto$2.lang = lang;
// Side effect imports
// FORMATTING
addFormatToken(X,0,0,unix);
addFormatToken(x,0,0,valueOf);
// PARSING
addRegexToken(x,matchSigned);
addRegexToken(X,matchTimestamp);
addParseToken(X,function (input,array,config){config_d:new Date(parseFloat(input,10) * 1000)});
addParseToken(x,function (input,array,config){config_d:new Date(toInt(input))});
// Side effect imports
hooks.version = 2.24.0;
setHookCallback(createLocal);
hooks.fn = proto;
hooks.min = min;
hooks.max = max;
hooks.now = now;
hooks.utc = createUTC;
hooks.unix = createUnix;
hooks.months = listMonths;
hooks.isDate = isDate;
hooks.locale = getSetGlobalLocale;
hooks.invalid = createInvalid;
hooks.duration = createDuration;
hooks.isMoment = isMoment;
hooks.weekdays = listWeekdays;
hooks.parseZone = createInZone;
hooks.localeData = getLocale;
hooks.isDuration = isDuration;
hooks.monthsShort = listMonthsShort;
hooks.weekdaysMin = listWeekdaysMin;
hooks.defineLocale = defineLocale;
hooks.updateLocale = updateLocale;
hooks.locales = listLocales;
hooks.weekdaysShort = listWeekdaysShort;
hooks.normalizeUnits = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat = getCalendarFormat;
hooks.prototype = proto;
// currently HTML5 input type only supports 24-hour formats
hooks.HTML5_FMT ={datetime_local:YYYY-MM-DDTHH:mm,// <input type=datetime-local /> DATETIME_LOCAL_SECONDS: YYYY-MM-DDTHH:mm:ss,// <input type=datetime-local step=1 /> DATETIME_LOCAL_MS: YYYY-MM-DDTHH:mm:ss.SSS,// <input type=datetime-local step=0.001 /> DATE: YYYY-MM-DD,// <input type=date /> TIME: HH:mm,// <input type=time /> TIME_SECONDS: HH:mm:ss,// <input type=time step=1 /> TIME_MS: HH:mm:ss.SSS,// <input type=time step=0.001 /> WEEK: GGGG-[W]WW,// <input type=week /> MONTH: YYYY-MM // <input type=month />}