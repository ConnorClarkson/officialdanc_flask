(function(global,factory){typeofexports:==object&&typeof module!==undefined?module.exports=factory():typeof define===function&&define.amd?define(factory):(global.Popper=factory())}(this,(function(){varisbrowser:typeof window!==undefined&&typeof document!==undefined;varlongertimeoutbrowsers:[Edge,Trident,Firefox];vartimeoutduration:0;forvari:0;i:1){if(isBrowser&&navigator.userAgent.indexOf(longerTimeoutBrowsers[i])>=0){timeoutDuration=1}function microtaskDebounce(fn){varcalled:!1}called=!0;window.Promise.resolve().then(function(){called:!1}function taskDebounce(fn){varscheduled:!1;returnfunctionifscheduledscheduled:!0;settimeoutfunctionscheduled:!1}var supportsMicroTasks=isBrowser&&window.Promise;\Avar debounce=supportsMicroTasks?microtaskDebounce:taskDebounce;\A\A\Afunction isFunction(functionToCheck){\A var getType={};\A return functionToCheck&&getType.toString.call(functionToCheck)==='[object Function]';\A}\A\A\Afunction getStyleComputedProperty(element,property){\A if(element.nodeType!==1){\A return[];\A}\A
while(offsetParent===noOffsetParent&&element.nextElementSibling){offsetparent:(element=element.nextElementSibling).offsetParent}var nodeName=offsetParent&&offsetParent.nodeName;if(!nodeName||nodeName===BODY||nodeName===HTML){returnelementelementownerdocumentdocumentelement:document.documentElement}function isOffsetContainer(element){varnodename:element.nodeName;ifnodename:==BODY){return!1}function getRoot(node){ifnodeparentnode:=null){return getRoot(node.parentNode)}function getScroll(element){varside:arguments.length>1&&arguments[1]!==undefined?arguments[1]:top;varupperside:side===top?scrollTop:scrollLeft;varnodename:element.nodeName;ifnodename:==BODY||nodeName===HTML){var html=element.ownerDocument.documentElement;varscrollingelement:element.ownerDocument.scrollingElement||html}function includeScroll(rect,element){varsubtract:arguments.length>2&&arguments[2]!==undefined?arguments[2]:!1;varscrolltop:getScroll(element,'top');varscrollleft:getScroll(element,'left');varmodifier:subtract?-1:1;recttop:scrollTop*modifier;rectbottom:scrollTop*modifier;rectleft:scrollLeft*modifier;rectright:scrollLeft*modifier}function getBordersSize(styles,axis){varsidea:axis===x?Left:Top;varsideb:sideA===Left?Right:Bottom}function getSize(axis,body,html,computedStyle){returnmathmaxbodyoffsetaxisbodyscrollaxishtmlclientaxishtmloffsetaxishtmlscrollaxisisie10parseinthtmloffsetaxisparseintcomputedstylemarginaxis:==Height?Top:Left)])+parseInt(computedStyle['margin'+(axis==='Height'?'Bottom':'Right')]):0)}function getWindowSizes(document){varbody:document.body;varhtml:document.documentElement;varcomputedstyle:isIE(10)&&getComputedStyle(html);returnheight:getSize(Height,body,html,computedStyle),;width:getSize(Width,body,html,computedStyle)};var createClass=function(){functiondefinepropertiestargetpropsforvari:0;ivardescriptor:props[i];descriptorenumerable:descriptor.enumerable||!1;descriptorconfigurable:!0;ifvalueindescriptordescriptorwritable:!0}();var defineProperty=function(obj,key,value){ifkeyinobjobjectdefinepropertyobjkeyvalue:value,enumerable:!0,configurable:!0,writable:!0}else{objkey:value};var _extends=Object.assign||function(target){forvari:1;ivarsource:arguments[i];forvarkeyinsourceifobjectprototypehasownpropertycallsourcekeytargetkey:source[key]},offsets,{right:offsets.left+offsets.width,;bottom:offsets.top+offsets.height}function getBoundingClientRect(element){varrect:{};if(horizScrollbar||vertScrollbar){varstyles:getStyleComputedProperty(element);horizscrollbar-:getBordersSize(styles,'x');vertscrollbar-:getBordersSize(styles,'y');resultwidth-:horizScrollbar;resultheight-:vertScrollbar}function getOffsetRectRelativeToArbitraryNode(children,parent){varfixedposition:arguments.length>2&&arguments[2]!==undefined?arguments[2]:!1;varisie10:isIE(10);varishtml:parent.nodeName===HTML;varchildrenrect:getBoundingClientRect(children);varparentrect:getBoundingClientRect(parent);varscrollparent:getScrollParent(children);varstyles:getStyleComputedProperty(parent);varbordertopwidth:parseFloat(styles.borderTopWidth,10);varborderleftwidth:parseFloat(styles.borderLeftWidth,10);parentrectleft:Math.max(parentRect.left,0)}var offsets=getClientRect({top:childrenRect.top-parentRect.top-borderTopWidth,;left:childrenRect.left-parentRect.left-borderLeftWidth,;width:childrenRect.width,;height:childrenRect.height});offsets.marginTop=0;offsets.marginLeft=0;if(!isIE10&&isHTML){varmargintop:parseFloat(styles.marginTop,10);varmarginleft:parseFloat(styles.marginLeft,10);offsetstop-:borderTopWidth-marginTop;offsetsbottom-:borderTopWidth-marginTop;offsetsleft-:borderLeftWidth-marginLeft;offsetsright-:borderLeftWidth-marginLeft;offsetsmarginleft:marginLeft}if(isIE10&&!fixedPosition?parent.contains(scrollParent):parent===scrollParent&&scrollParent.nodeName!==BODY){offsets:includeScroll(offsets,parent)}function getViewportOffsetRectRelativeToArtbitraryNode(element){varexcludescroll:arguments.length>1&&arguments[1]!==undefined?arguments[1]:!1;varhtml:element.ownerDocument.documentElement;varrelativeoffset:getOffsetRectRelativeToArbitraryNode(element,html);varwidth:Math.max(html.clientWidth,window.innerWidth||0);varheight:Math.max(html.clientHeight,window.innerHeight||0);varscrolltop:!excludeScroll?getScroll(html):0;varscrollleft:!excludeScroll?getScroll(html,'left'):0;varoffset:{;top:scrollTop-relativeOffset.top+relativeOffset.marginTop,;left:scrollLeft-relativeOffset.left+relativeOffset.marginLeft,;width:width,;height:height}function isFixed(element){varnodename:element.nodeName;ifnodename:==BODY||nodeName===HTML){return!1}var el=element.parentElement;while(el&&getStyleComputedProperty(el,transform)===none){el:el.parentElement}function getBoundaries(popper,reference,padding,boundariesElement){varfixedposition:arguments.length>4&&arguments[4]!==undefined?arguments[4]:!1};var offsetParent=fixedPosition?getFixedPositionOffsetParent(popper):findCommonOffsetParent(popper,reference);if(boundariesElement===viewport){boundaries:getViewportOffsetRectRelativeToArtbitraryNode(offsetParent,fixedPosition)}else{ifboundarieselement:==scrollParent){boundariesNode=getScrollParent(getParentNode(reference));ifboundariesnodenodename:==BODY){boundariesNode=popper.ownerDocument.documentElement}else if(boundariesElement===window){boundariesnode:popper.ownerDocument.documentElement}else{boundariesnode:boundariesElement}var offsets=getOffsetRectRelativeToArbitraryNode(boundariesNode,offsetParent,fixedPosition);if(boundariesNode.nodeName===HTML&&!isFixed(offsetParent)){var_getwindowsizes:getWindowSizes(popper.ownerDocument),height=_getWindowSizes.height,width=_getWindowSizes.width;boundariestop:offsets.top-offsets.marginTop;boundariesbottom:height+offsets.top;boundariesleft:offsets.left-offsets.marginLeft;boundariesright:width+offsets.left}else{}function getArea(_ref){varwidth:_ref.width,height=_ref.height}function computeAutoPlacement(placement,refRect,popper,reference,boundariesElement){varpadding:arguments.length>5&&arguments[5]!==undefined?arguments[5]:0;ifplacementindexofauto:==-1){return placement}var boundaries=getBoundaries(popper,reference,padding,boundariesElement);var rects={top:{;width:boundaries.width,;height:refRect.top-boundaries.top},right:{width:boundaries.right-refRect.right,;height:boundaries.height},bottom:{width:boundaries.width,;height:boundaries.bottom-refRect.bottom},left:{width:refRect.left-boundaries.left,;height:boundaries.height};var sortedAreas=Object.keys(rects).map(function(key){return_extendskey:key},rects[key],{area:getArea(rects[key])});var filteredAreas=sortedAreas.filter(function(_ref2){varwidth:_ref2.width,height=_ref2.height;returnwidth:popper.clientWidth&&height>=popper.clientHeight}function getReferenceOffsets(state,popper,reference){varfixedposition:arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;varcommonoffsetparent:fixedPosition?getFixedPositionOffsetParent(popper):findCommonOffsetParent(popper,reference)}function getOuterSizes(element){varstyles:getComputedStyle(element);varx:parseFloat(styles.marginTop)+parseFloat(styles.marginBottom);vary:parseFloat(styles.marginLeft)+parseFloat(styles.marginRight);varresult:{;width:element.offsetWidth+y,;height:element.offsetHeight+x}function getOppositePlacement(placement){varhash:{left:right,right:left,bottom:top,top:bottom}function getPopperOffsets(popper,referenceOffsets,placement){placement:placement.split(-)[0];width:popperRect.width,;height:popperRect.height};var isHoriz=[right,left].indexOf(placement)!==-1;var mainSide=isHoriz?top:left;var secondarySide=isHoriz?left:top;var measurement=isHoriz?height:width;var secondaryMeasurement=!isHoriz?height:width;popperOffsets[mainSide]=referenceOffsets[mainSide]+referenceOffsets[measurement]/2-popperRect[measurement]/2;if(placement===secondarySide){popperoffsetssecondaryside:referenceOffsets[secondarySide]-popperRect[secondaryMeasurement]}else{popperoffsetssecondaryside:referenceOffsets[getOppositePlacement(secondarySide)]}function findIndex(arr,prop,value){}var data={instance:this,styles:{};data.offsets.reference=getReferenceOffsets(this.state,this.popper,this.reference,this.options.positionFixed);data.placement=computeAutoPlacement(this.options.placement,data.offsets.reference,this.popper,this.reference,this.options.modifiers.flip.boundariesElement,this.options.modifiers.flip.padding);data.originalPlacement=data.placement;data.positionFixed=this.options.positionFixed;data.offsets.popper=getPopperOffsets(this.popper,data.offsets.reference,data.placement);data.offsets.popper.position=this.options.positionFixed?fixed:absolute;data=runModifiers(this.modifiers,data);if(!this.state.isCreated){thisstateiscreated:!0}function isModifierEnabled(modifiers,modifierName){returnmodifierssomefunction_refvarname:_ref.name,enabled=_ref.enabled;returnenabledname:==modifierName}function getSupportedPropertyName(property){varprefixes:[!1,ms,Webkit,Moz,O];varupperprop:property.charAt(0).toUpperCase()+property.slice(1);forvari:0;ivarprefix:prefixes[i];vartocheck:prefix?+prefix+upperProp:property;iftypeofdocumentbodystyletocheck:=undefined){return toCheck}function destroy(){thisstateisdestroyed:!0}this.disableEventListeners();*when they are triggered.It also won't trigger `onUpdate` callback anymore,\A * unless you call `update` method manually.\A * @method\A * @memberof Popper\A */\Afunction disableEventListeners() {\A  if (this.state.eventsEnabled) {\A    cancelAnimationFrame(this.scheduleUpdate);\A    this.state = removeEventListeners(this.reference, this.state);\A  }\A}\A\A/**\A * Tells if a given input is a number\A * @method\A * @memberof Popper.Utils\A * @param {*} input to check\A * @return {Boolean}\A */\Afunction isNumeric(n) {\A  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\A}\A\A/**\A * Set the style to the given popper\A * @method\A * @memberof Popper.Utils\A * @argument {Element} element - Element to apply the style to\A * @argument {Object} styles\A * Object with a list of properties and values which will be applied to the element\A */\Afunction setStyles(element, styles) {\A  Object.keys(styles).forEach(function (prop) {\A    var unit = '';\A    // add unit if the value is numeric and is one of the following\A    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\A      unit = 'px';\A    }\A    element.style[prop] = styles[prop] + unit;\A  });\A}\A\A/**\A * Set the attributes to the given popper\A * @method\A * @memberof Popper.Utils\A * @argument {Element} element - Element to apply the attributes to\A * @argument {Object} styles\A * Object with a list of properties and values which will be applied to the element\A */\Afunction setAttributes(element, attributes) {\A  Object.keys(attributes).forEach(function (prop) {\A    var value = attributes[prop];\A    if (value !== false) {\A      element.setAttribute(prop, attributes[prop]);\A    } else {\A      element.removeAttribute(prop);\A    }\A  });\A}\A\A/**\A * @function\A * @memberof Modifiers\A * @argument {Object} data - The data object generated by `update` method\A * @argument {Object} data.styles - List of style properties - values to apply to popper element\A * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element\A * @argument {Object} options - Modifiers configuration and options\A * @returns {Object} The same data object\A */\Afunction applyStyle(data) {\A  // any property present in `data.styles` will be applied to the popper,\A  // in this way we can make the 3rd party modifiers add custom styles to it\A  // Be aware, modifiers could override the properties defined in the previous\A  // lines of this modifier!\A  setStyles(data.instance.popper, data.styles);\A\A  // any property present in `data.attributes` will be applied to the popper,\A  // they will be set as HTML attributes of the element\A  setAttributes(data.instance.popper, data.attributes);\A\A  // if arrowElement is defined and arrowStyles has some properties\A  if (data.arrowElement && Object.keys(data.arrowStyles).length) {\A    setStyles(data.arrowElement, data.arrowStyles);\A  }\A\A  return data;\A}\A\A/**\A * Set the x-placement attribute before everything else because it could be used\A * to add margins to the popper margins needs to be calculated to get the\A * correct popper offsets.\A * @method\A * @memberof Popper.modifiers\A * @param {HTMLElement} reference - The reference element used to position the popper\A * @param {HTMLElement} popper - The HTML element used as popper\A * @param {Object} options - Popper.js options\A */\Afunction applyStyleOnLoad(reference, popper, options, modifierOptions, state) {\A  // compute reference element offsets\A  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);\A\A  // compute auto placement, store placement inside the data object,\A  // modifiers will be able to edit `placement` if needed\A  // and refer to originalPlacement to know the original value\A  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);\A\A  popper.setAttribute('x-placement', placement);\A\A  // Apply `position` to popper before anything else because\A  // without the position applied we can't guarantee correct computations
setStyles(popper,{position:options.positionFixed?fixed:absolute}function computeStyle(data,options){varx:options.x,y=options.y;varpopper:data.offsets.popper;iflegacygpuaccelerationoption:=undefined){console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!')}var gpuAcceleration=legacyGpuAccelerationOption!==undefined?legacyGpuAccelerationOption:options.gpuAcceleration;var offsetParent=getOffsetParent(data.instance.popper);var offsetParentRect=getBoundingClientRect(offsetParent);var styles={position:popper.position};var offsets={left:Math.floor(popper.left),;top:Math.round(popper.top),;bottom:Math.round(popper.bottom),;right:Math.floor(popper.right)};var sideA=x===bottom?top:bottom;var sideB=y===right?left:right;var prefixedProperty=getSupportedPropertyName(transform);var left=void 0,top=void 0;if(sideA===bottom){}else{top:-offsetParentRect.height+offsets.bottom}else{top:offsets.top}if(sideB===right){ifoffsetparentnodename:==HTML){left=-offsetParent.clientWidth+offsets.right}else{left:-offsetParentRect.width+offsets.right}else{left:offsets.left}if(gpuAcceleration&&prefixedProperty){stylesprefixedproperty:translate3d(+left+'px,'+top+'px,0)';stylessidea:0;stylessideb:0;styleswillchange:transform}else{varinvertleft:sideB===right?-1:1;stylessidea:top*invertTop;stylessideb:left*invertLeft;styleswillchange:sideA+','+sideB}
var attributes={'x-placement:data.placement}function isModifierRequired(modifiers,requestingName,requestedName){varrequesting:find(modifiers,function (_ref) { var name = _ref.name; return name === requestingName; });varisrequired:!!requesting && modifiers.some(function (modifier) { return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order; });ifisrequiredvar_requesting:` + requestingName + `;varrequested:` + requestedName + `}else{varpoppermarginside:parseFloat(css['margin' + sideCapitalized],10);varpopperborderside:parseFloat(css['border' + sideCapitalized + 'Width'],10);varsidevalue:center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;dataarrowelement:arrowElement;dataoffsetsarrow:(_data$offsets$arrow = {},defineProperty(_data$offsets$arrow,side,Math.round(sideValue)),defineProperty(_data$offsets$arrow,altSide,''),_data$offsets$arrow)}function getOppositeVariation(variation){ifvariation:== end) { return start}placements including their variations
*/
function clockwise(placement){varcounter:arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;varindex:validPlacements.indexOf(placement);vararr:validPlacements.slice(index + 1).concat(validPlacements.slice(0,index));returncounterarrreverse:arr}var BEHAVIORS ={flip:flip,CLOCKWISE: clockwise,COUNTERCLOCKWISE: counterclockwise}var boundaries = getBoundaries(data.instance.popper,data.instance.reference,options.padding,options.boundariesElement,data.positionFixed);
var placement = data.placement.split(-)[0];
var placementOpposite = getOppositePlacement(placement);
var variation = data.placement.split(-)[1] || ;
var flipOrder = [];
switch (options.behavior){casebehaviorsflip:flipOrder = [placement,placementOpposite];casebehaviorsclockwise:flipOrder = clockwise(placement);casebehaviorscounterclockwise:flipOrder = clockwise(placement,true);default:flipOrder = options.behavior}flipOrder.forEach(function (step,index){ifplacement:= step || flipOrder.length === index + 1) { return data}placement = data.placement.split(-)[0];
placementOpposite = getOppositePlacement(placement);
var popperOffsets = data.offsets.popper;
var refOffsets = data.offsets.reference;
// using floor because the reference offsets may contain decimals we are not going to consider here
var floor = Math.floor;
var overlapsRef = placement === left && floor(popperOffsets.right) > floor(refOffsets.left) || placement === right && floor(popperOffsets.left) < floor(refOffsets.right) || placement === top && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === bottom && floor(popperOffsets.top) < floor(refOffsets.bottom);
var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
var overflowsBoundaries = placement === left && overflowsLeft || placement === right && overflowsRight || placement === top && overflowsTop || placement === bottom && overflowsBottom;
// flip the variation if required
var isVertical = [top,bottom].indexOf(placement) !== -1;
var flippedVariation = !!options.flipVariations && (isVertical && variation === start && overflowsLeft || isVertical && variation === end && overflowsRight || !isVertical && variation === start && overflowsTop || !isVertical && variation === end && overflowsBottom);
if (overlapsRef || overflowsBoundaries || flippedVariation){ifoverlapsrefoverflowsboundariesplacement:flipOrder[index + 1]}if (flippedVariation){variation:getOppositeVariation(variation)}function keepTogether(data){var_dataoffsets:data.offsets,popper = _data$offsets.popper,reference = _data$offsets.reference;varplacement:data.placement.split(-)[0];varfloor:Math.floor;varisvertical:[top,bottom].indexOf(placement) !== -1;varside:isVertical ? right : bottom;varopside:isVertical ? left : top;varmeasurement:isVertical ? width : height;ifpoppersidefloorreferenceopsidedataoffsetspopperopside:floor(reference[opSide]) - popper[measurement]}if (popper[opSide] > floor(reference[side])){dataoffsetspopperopside:floor(reference[side])}function toValue(str,measurement,popperOffsets,referenceOffsets){varvalue:+split[1];varunit:split[2]}if (unit.indexOf(%) === 0){varelement:void 0;switchunitcasep:element = popperOffsets;case:case %r: default: element = referenceOffsets}else if (unit === vh || unit === vw){ifunit:== vh) { size = Math.max(document.documentElement.clientHeight,window.innerHeight || 0)}else{size:Math.max(document.documentElement.clientWidth,window.innerWidth || 0)}function parseOffset(offset,popperOffsets,referenceOffsets,basePlacement){varoffsets:[0,0];iffragmentsdividerfragmentsdividerindexof:== -1) { console.warn('Offsets separated by white space(s)are deprecated,use a comma(,)instead.')}// If divider is found,we divide the list of values and operands to divide
// them by ofset X and Y.
var splitRegex = /s*,s*|s+/;
var ops = divider !== -1 ? [fragments.slice(0,divider).concat([fragments[divider].split(splitRegex)[0]]),[fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];
// Convert the values with units to absolute pixels to allow our computations
ops = ops.map(function (op,index){varmergewithprevious:false;returnop//thisaggregatesanyor-signthatarentconsideredoperators//eg:10 + 5 => [10,+,+5] .reduce(function (a,b) { if (a[a.length - 1] === '' && ['+','-'].indexOf(b) !== -1) { a[a.length - 1] = b; mergeWithPrevious = true; return a; } else if (mergeWithPrevious) { a[a.length - 1] += b; mergeWithPrevious = false; return a; } else { return a.concat(b); } },[]) // Here we convert the string values into number values (in px) .map(function (str) { return toValue(str,measurement,popperOffsets,referenceOffsets); })});
// Loop trough the offsets arrays and execute the operations
ops.forEach(function (op,index){opforeachfunctionfragindex2ifisnumericfragoffsetsindex:frag * (op[index2 - 1] === '-' ? -1 : 1)}function offset(data,_ref){varoffset:_ref.offset;varplacement:data.placement,_data$offsets = data.offsets,popper = _data$offsets.popper,reference = _data$offsets.reference;varbaseplacement:placement.split(-)[0];varoffsets:void 0;ifisnumericoffsetoffsets:[+offset,0]}else{offsets:parseOffset(offset,popper,reference,basePlacement)}if (basePlacement === left){poppertop:offsets[0];popperleft-:offsets[1]}else if (basePlacement === right){poppertop:offsets[0];popperleft:offsets[1]}else if (basePlacement === top){popperleft:offsets[0];poppertop-:offsets[1]}else if (basePlacement === bottom){popperleft:offsets[0];poppertop:offsets[1]}function preventOverflow(data,options){varboundarieselement:options.boundariesElement || getOffsetParent(data.instance.popper)}else{}function inner(data){varplacement:data.placement;varbaseplacement:placement.split(-)[0];var_dataoffsets:data.offsets,popper = _data$offsets.popper,reference = _data$offsets.reference;varishoriz:[left,right].indexOf(basePlacement) !== -1;varsubtractlength:[top,left].indexOf(basePlacement) === -1;popperishorizleft:top] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);dataplacement:getOppositePlacement(placement);dataoffsetspopper:getClientRect(popper)}var modifiers ={shift:{ order: 100,enabled: true,fn: shift},/**
* The `offset` modifier can shift your popper on both its axis.
*
* It accepts the following units:
* - `px` or unit-less,interpreted as pixels
* - `%` or `%r`,percentage relative to the length of the reference element
* - `%p`,percentage relative to the length of the popper element
* - `vw`,CSS viewport width unit
* - `vh`,CSS viewport height unit
*
* For length is intended the main axis relative to the placement of the popper.<br />
* This means that if the placement is `top` or `bottom`,the length will be the
* `width`. In case of `left` or `right`,it will be the `height`.
*
* You can provide a single value (as `Number` or `String`),or a pair of values
* as `String` divided by a comma or one (or more) white spaces.<br />
* The latter is a deprecated method because it leads to confusion and will be
* removed in v2.<br />
* Additionally,it accepts additions and subtractions between different units.
* Note that multiplications and divisions aren't supported.\A*\A*Valid examples are:\A*```\A   * 10\A   * '10%'\A   * '10,10'\A   * '10%,10'\A   * '10 + 10%'\A   * '10 - 5vh + 3%'\A   * '-10px + 5vh,5px - 6%'\A   * ```\A*>**NB**:If you desire to apply offsets to your poppers in a way that may make them overlap\A*>with their reference element,unfortunately,you will have to disable the `flip` modifier.\A*>You can read more on this at this[issue](https:*reference element.**Requires the `preventOverflow` modifier before it in order to work.****NOTE:**this modifier will interrupt the current update cycle and will*restart it if it detects the need to flip the placement.*@memberof modifiers*@inner*/flip:{order:600,enabled:!0,fn:flip,behavior:flip,;padding:5,boundariesElement:viewport},inner:{order:700,enabled:!1,fn:inner},hide:{order:800,enabled:!0,fn:hide},computeStyle:{order:850,enabled:!0,fn:computeStyle,gpuAcceleration:!0,x:bottom,y:right},applyStyle:{order:900,enabled:!0,fn:applyStyle,onLoad:applyStyleOnLoad,gpuAcceleration:undefined}data.offsets.arrow]`top` and `left` offsets,only one of them will be different from 0*/var Defaults={placement:bottom,positionFixed:!1,eventsEnabled:!0,removeOnDestroy:!1,onCreate:function onCreate(){}data*/var Popper=function(){functionpopperreferencepoppervar_this:this;varoptions:arguments.length>2&&arguments[2]!==undefined?arguments[2]:{},Popper.Defaults,options);this.state={isdestroyed:!1,isCreated:!1,scrollParents:[]},Popper.Defaults.modifiers,options.modifiers)).forEach(function(name){_thisoptionsmodifiersname:_extends({},Popper.Defaults.modifiers[name]||{},options.modifiers?options.modifiers[name]:{})}
createClass(Popper,[{key:update,value:function update$$1(){return update.call(this)},{key:destroy,value:function destroy$$1(){return destroy.call(this);key:enableEventListeners,value:function enableEventListeners$$1(){return enableEventListeners.call(this);key:disableEventListeners,value:function disableEventListeners$$1(){return disableEventListeners.call(this)}